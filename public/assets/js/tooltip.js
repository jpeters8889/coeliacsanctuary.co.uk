/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["tooltip"],{

/***/ "./node_modules/v-tooltip/dist/v-tooltip.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/v-tooltip/dist/v-tooltip.esm.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"VClosePopover\": () => (/* binding */ VClosePopover),\n/* harmony export */   \"VPopover\": () => (/* binding */ VPopover),\n/* harmony export */   \"VTooltip\": () => (/* binding */ VTooltip),\n/* harmony export */   \"createTooltip\": () => (/* binding */ createTooltip),\n/* harmony export */   \"destroyTooltip\": () => (/* binding */ destroyTooltip),\n/* harmony export */   \"install\": () => (/* binding */ install)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var popper_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! popper.js */ \"./node_modules/popper.js/dist/esm/popper.js\");\n/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/isEqual */ \"./node_modules/lodash/isEqual.js\");\n/* harmony import */ var lodash_isEqual__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_isEqual__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var vue_resize__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vue-resize */ \"./node_modules/vue-resize/dist/vue-resize.esm.js\");\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/merge */ \"./node_modules/lodash/merge.js\");\n/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\n\n\nvar SVGAnimatedString = function SVGAnimatedString() {};\n\nif (typeof window !== 'undefined') {\n  SVGAnimatedString = window.SVGAnimatedString;\n}\n\nfunction convertToArray(value) {\n  if (typeof value === 'string') {\n    value = value.split(' ');\n  }\n\n  return value;\n}\n/**\n * Add classes to an element.\n * This method checks to ensure that the classes don't already exist before adding them.\n * It uses el.className rather than classList in order to be IE friendly.\n * @param {object} el - The element to add the classes to.\n * @param {classes} string - List of space separated classes to be added to the element.\n */\n\nfunction addClasses(el, classes) {\n  var newClasses = convertToArray(classes);\n  var classList;\n\n  if (el.className instanceof SVGAnimatedString) {\n    classList = convertToArray(el.className.baseVal);\n  } else {\n    classList = convertToArray(el.className);\n  }\n\n  newClasses.forEach(function (newClass) {\n    if (classList.indexOf(newClass) === -1) {\n      classList.push(newClass);\n    }\n  });\n\n  if (el instanceof SVGElement) {\n    el.setAttribute('class', classList.join(' '));\n  } else {\n    el.className = classList.join(' ');\n  }\n}\n/**\n * Remove classes from an element.\n * It uses el.className rather than classList in order to be IE friendly.\n * @export\n * @param {any} el The element to remove the classes from.\n * @param {any} classes List of space separated classes to be removed from the element.\n */\n\nfunction removeClasses(el, classes) {\n  var newClasses = convertToArray(classes);\n  var classList;\n\n  if (el.className instanceof SVGAnimatedString) {\n    classList = convertToArray(el.className.baseVal);\n  } else {\n    classList = convertToArray(el.className);\n  }\n\n  newClasses.forEach(function (newClass) {\n    var index = classList.indexOf(newClass);\n\n    if (index !== -1) {\n      classList.splice(index, 1);\n    }\n  });\n\n  if (el instanceof SVGElement) {\n    el.setAttribute('class', classList.join(' '));\n  } else {\n    el.className = classList.join(' ');\n  }\n}\nvar supportsPassive = false;\n\nif (typeof window !== 'undefined') {\n  supportsPassive = false;\n\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      get: function get() {\n        supportsPassive = true;\n      }\n    });\n    window.addEventListener('test', null, opts);\n  } catch (e) {}\n}\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar DEFAULT_OPTIONS = {\n  container: false,\n  delay: 0,\n  html: false,\n  placement: 'top',\n  title: '',\n  template: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n  trigger: 'hover focus',\n  offset: 0\n};\nvar openTooltips = [];\n\nvar Tooltip = /*#__PURE__*/function () {\n  /**\n   * Create a new Tooltip.js instance\n   * @class Tooltip\n   * @param {HTMLElement} reference - The DOM node used as reference of the tooltip (it can be a jQuery element).\n   * @param {Object} options\n   * @param {String} options.placement=bottom\n   *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -end),\n   *      left(-start, -end)`\n   * @param {HTMLElement|String|false} options.container=false - Append the tooltip to a specific element.\n   * @param {Number|Object} options.delay=0\n   *      Delay showing and hiding the tooltip (ms) - does not apply to manual trigger type.\n   *      If a number is supplied, delay is applied to both hide/show.\n   *      Object structure is: `{ show: 500, hide: 100 }`\n   * @param {Boolean} options.html=false - Insert HTML into the tooltip. If false, the content will inserted with `innerText`.\n   * @param {String|PlacementFunction} options.placement='top' - One of the allowed placements, or a function returning one of them.\n   * @param {String} [options.template='<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>']\n   *      Base HTML to used when creating the tooltip.\n   *      The tooltip's `title` will be injected into the `.tooltip-inner` or `.tooltip__inner`.\n   *      `.tooltip-arrow` or `.tooltip__arrow` will become the tooltip's arrow.\n   *      The outermost wrapper element should have the `.tooltip` class.\n   * @param {String|HTMLElement|TitleFunction} options.title='' - Default title value if `title` attribute isn't present.\n   * @param {String} [options.trigger='hover focus']\n   *      How tooltip is triggered - click, hover, focus, manual.\n   *      You may pass multiple triggers; separate them with a space. `manual` cannot be combined with any other trigger.\n   * @param {HTMLElement} options.boundariesElement\n   *      The element used as boundaries for the tooltip. For more information refer to Popper.js'\n   *      [boundariesElement docs](https://popper.js.org/popper-documentation.html)\n   * @param {Number|String} options.offset=0 - Offset of the tooltip relative to its reference. For more information refer to Popper.js'\n   *      [offset docs](https://popper.js.org/popper-documentation.html)\n   * @param {Object} options.popperOptions={} - Popper options, will be passed directly to popper instance. For more information refer to Popper.js'\n   *      [options docs](https://popper.js.org/popper-documentation.html)\n   * @param {string} [options.ariaId] Id used for accessibility\n   * @return {Object} instance - The generated tooltip instance\n   */\n  function Tooltip(_reference, _options) {\n    var _this = this;\n\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_2__.default)(this, Tooltip);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)(this, \"_events\", []);\n\n    (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)(this, \"_setTooltipNodeEvent\", function (evt, reference, delay, options) {\n      var relatedreference = evt.relatedreference || evt.toElement || evt.relatedTarget;\n\n      var callback = function callback(evt2) {\n        var relatedreference2 = evt2.relatedreference || evt2.toElement || evt2.relatedTarget; // Remove event listener after call\n\n        _this._tooltipNode.removeEventListener(evt.type, callback); // If the new reference is not the reference element\n\n\n        if (!reference.contains(relatedreference2)) {\n          // Schedule to hide tooltip\n          _this._scheduleHide(reference, options.delay, options, evt2);\n        }\n      };\n\n      if (_this._tooltipNode.contains(relatedreference)) {\n        // listen to mouseleave on the tooltip element to be able to hide the tooltip\n        _this._tooltipNode.addEventListener(evt.type, callback);\n\n        return true;\n      }\n\n      return false;\n    });\n\n    // apply user options over default ones\n    _options = _objectSpread$2(_objectSpread$2({}, DEFAULT_OPTIONS), _options);\n    _reference.jquery && (_reference = _reference[0]);\n    this.show = this.show.bind(this);\n    this.hide = this.hide.bind(this); // cache reference and options\n\n    this.reference = _reference;\n    this.options = _options; // set initial state\n\n    this._isOpen = false;\n\n    this._init();\n  } //\n  // Public methods\n  //\n\n  /**\n   * Reveals an element's tooltip. This is considered a \"manual\" triggering of the tooltip.\n   * Tooltips with zero-length titles are never displayed.\n   * @method Tooltip#show\n   * @memberof Tooltip\n   */\n\n\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_3__.default)(Tooltip, [{\n    key: \"show\",\n    value: function show() {\n      this._show(this.reference, this.options);\n    }\n    /**\n     * Hides an element’s tooltip. This is considered a “manual” triggering of the tooltip.\n     * @method Tooltip#hide\n     * @memberof Tooltip\n     */\n\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      this._hide();\n    }\n    /**\n     * Hides and destroys an element’s tooltip.\n     * @method Tooltip#dispose\n     * @memberof Tooltip\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this._dispose();\n    }\n    /**\n     * Toggles an element’s tooltip. This is considered a “manual” triggering of the tooltip.\n     * @method Tooltip#toggle\n     * @memberof Tooltip\n     */\n\n  }, {\n    key: \"toggle\",\n    value: function toggle() {\n      if (this._isOpen) {\n        return this.hide();\n      } else {\n        return this.show();\n      }\n    }\n  }, {\n    key: \"setClasses\",\n    value: function setClasses(classes) {\n      this._classes = classes;\n    }\n  }, {\n    key: \"setContent\",\n    value: function setContent(content) {\n      this.options.title = content;\n\n      if (this._tooltipNode) {\n        this._setContent(content, this.options);\n      }\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var classesUpdated = false;\n      var classes = options && options.classes || directive.options.defaultClass;\n\n      if (!lodash_isEqual__WEBPACK_IMPORTED_MODULE_4___default()(this._classes, classes)) {\n        this.setClasses(classes);\n        classesUpdated = true;\n      }\n\n      options = getOptions(options);\n      var needPopperUpdate = false;\n      var needRestart = false;\n\n      if (this.options.offset !== options.offset || this.options.placement !== options.placement) {\n        needPopperUpdate = true;\n      }\n\n      if (this.options.template !== options.template || this.options.trigger !== options.trigger || this.options.container !== options.container || classesUpdated) {\n        needRestart = true;\n      }\n\n      for (var key in options) {\n        this.options[key] = options[key];\n      }\n\n      if (this._tooltipNode) {\n        if (needRestart) {\n          var isOpen = this._isOpen;\n          this.dispose();\n\n          this._init();\n\n          if (isOpen) {\n            this.show();\n          }\n        } else if (needPopperUpdate) {\n          this.popperInstance.update();\n        }\n      }\n    } //\n    // Private methods\n    //\n\n  }, {\n    key: \"_init\",\n    value: function _init() {\n      // get events list\n      var events = typeof this.options.trigger === 'string' ? this.options.trigger.split(' ') : [];\n      this._isDisposed = false;\n      this._enableDocumentTouch = events.indexOf('manual') === -1;\n      events = events.filter(function (trigger) {\n        return ['click', 'hover', 'focus'].indexOf(trigger) !== -1;\n      }); // set event listeners\n\n      this._setEventListeners(this.reference, events, this.options); // title attribute\n\n\n      this.$_originalTitle = this.reference.getAttribute('title');\n      this.reference.removeAttribute('title');\n      this.reference.setAttribute('data-original-title', this.$_originalTitle);\n    }\n    /**\n     * Creates a new tooltip node\n     * @memberof Tooltip\n     * @private\n     * @param {HTMLElement} reference\n     * @param {String} template\n     * @param {String|HTMLElement|TitleFunction} title\n     * @param {Boolean} allowHtml\n     * @return {HTMLelement} tooltipNode\n     */\n\n  }, {\n    key: \"_create\",\n    value: function _create(reference, template) {\n      var _this2 = this;\n\n      // create tooltip element\n      var tooltipGenerator = window.document.createElement('div');\n      tooltipGenerator.innerHTML = template.trim();\n      var tooltipNode = tooltipGenerator.childNodes[0]; // add unique ID to our tooltip (needed for accessibility reasons)\n\n      tooltipNode.id = this.options.ariaId || \"tooltip_\".concat(Math.random().toString(36).substr(2, 10)); // Initially hide the tooltip\n      // The attribute will be switched in a next frame so\n      // CSS transitions can play\n\n      tooltipNode.setAttribute('aria-hidden', 'true');\n\n      if (this.options.autoHide && this.options.trigger.indexOf('hover') !== -1) {\n        tooltipNode.addEventListener('mouseenter', function (evt) {\n          return _this2._scheduleHide(reference, _this2.options.delay, _this2.options, evt);\n        });\n        tooltipNode.addEventListener('click', function (evt) {\n          return _this2._scheduleHide(reference, _this2.options.delay, _this2.options, evt);\n        });\n      } // return the generated tooltip node\n\n\n      return tooltipNode;\n    }\n  }, {\n    key: \"_setContent\",\n    value: function _setContent(content, options) {\n      var _this3 = this;\n\n      this.asyncContent = false;\n\n      this._applyContent(content, options).then(function () {\n        if (!_this3.popperInstance) return;\n\n        _this3.popperInstance.update();\n      });\n    }\n  }, {\n    key: \"_applyContent\",\n    value: function _applyContent(title, options) {\n      var _this4 = this;\n\n      return new Promise(function (resolve, reject) {\n        var allowHtml = options.html;\n        var rootNode = _this4._tooltipNode;\n        if (!rootNode) return;\n        var titleNode = rootNode.querySelector(_this4.options.innerSelector);\n\n        if (title.nodeType === 1) {\n          // if title is a node, append it only if allowHtml is true\n          if (allowHtml) {\n            while (titleNode.firstChild) {\n              titleNode.removeChild(titleNode.firstChild);\n            }\n\n            titleNode.appendChild(title);\n          }\n        } else if (typeof title === 'function') {\n          // if title is a function, call it and set innerText or innerHtml depending by `allowHtml` value\n          var result = title();\n\n          if (result && typeof result.then === 'function') {\n            _this4.asyncContent = true;\n            options.loadingClass && addClasses(rootNode, options.loadingClass);\n\n            if (options.loadingContent) {\n              _this4._applyContent(options.loadingContent, options);\n            }\n\n            result.then(function (asyncResult) {\n              options.loadingClass && removeClasses(rootNode, options.loadingClass);\n              return _this4._applyContent(asyncResult, options);\n            }).then(resolve).catch(reject);\n          } else {\n            _this4._applyContent(result, options).then(resolve).catch(reject);\n          }\n\n          return;\n        } else {\n          // if it's just a simple text, set innerText or innerHtml depending by `allowHtml` value\n          allowHtml ? titleNode.innerHTML = title : titleNode.innerText = title;\n        }\n\n        resolve();\n      });\n    }\n  }, {\n    key: \"_show\",\n    value: function _show(reference, options) {\n      if (options && typeof options.container === 'string') {\n        var container = document.querySelector(options.container);\n        if (!container) return;\n      }\n\n      clearTimeout(this._disposeTimer);\n      options = Object.assign({}, options);\n      delete options.offset;\n      var updateClasses = true;\n\n      if (this._tooltipNode) {\n        addClasses(this._tooltipNode, this._classes);\n        updateClasses = false;\n      }\n\n      var result = this._ensureShown(reference, options);\n\n      if (updateClasses && this._tooltipNode) {\n        addClasses(this._tooltipNode, this._classes);\n      }\n\n      addClasses(reference, ['v-tooltip-open']);\n      return result;\n    }\n  }, {\n    key: \"_ensureShown\",\n    value: function _ensureShown(reference, options) {\n      var _this5 = this;\n\n      // don't show if it's already visible\n      if (this._isOpen) {\n        return this;\n      }\n\n      this._isOpen = true;\n      openTooltips.push(this); // if the tooltipNode already exists, just show it\n\n      if (this._tooltipNode) {\n        this._tooltipNode.style.display = '';\n\n        this._tooltipNode.setAttribute('aria-hidden', 'false');\n\n        this.popperInstance.enableEventListeners();\n        this.popperInstance.update();\n\n        if (this.asyncContent) {\n          this._setContent(options.title, options);\n        }\n\n        return this;\n      } // get title\n\n\n      var title = reference.getAttribute('title') || options.title; // don't show tooltip if no title is defined\n\n      if (!title) {\n        return this;\n      } // create tooltip node\n\n\n      var tooltipNode = this._create(reference, options.template);\n\n      this._tooltipNode = tooltipNode; // Add `aria-describedby` to our reference element for accessibility reasons\n\n      reference.setAttribute('aria-describedby', tooltipNode.id); // append tooltip to container\n\n      var container = this._findContainer(options.container, reference);\n\n      this._append(tooltipNode, container);\n\n      var popperOptions = _objectSpread$2(_objectSpread$2({}, options.popperOptions), {}, {\n        placement: options.placement\n      });\n\n      popperOptions.modifiers = _objectSpread$2(_objectSpread$2({}, popperOptions.modifiers), {}, {\n        arrow: {\n          element: this.options.arrowSelector\n        }\n      });\n\n      if (options.boundariesElement) {\n        popperOptions.modifiers.preventOverflow = {\n          boundariesElement: options.boundariesElement\n        };\n      }\n\n      this.popperInstance = new popper_js__WEBPACK_IMPORTED_MODULE_7__.default(reference, tooltipNode, popperOptions);\n\n      this._setContent(title, options); // Fix position\n\n\n      requestAnimationFrame(function () {\n        if (!_this5._isDisposed && _this5.popperInstance) {\n          _this5.popperInstance.update(); // Show the tooltip\n\n\n          requestAnimationFrame(function () {\n            if (!_this5._isDisposed) {\n              _this5._isOpen && tooltipNode.setAttribute('aria-hidden', 'false');\n            } else {\n              _this5.dispose();\n            }\n          });\n        } else {\n          _this5.dispose();\n        }\n      });\n      return this;\n    }\n  }, {\n    key: \"_noLongerOpen\",\n    value: function _noLongerOpen() {\n      var index = openTooltips.indexOf(this);\n\n      if (index !== -1) {\n        openTooltips.splice(index, 1);\n      }\n    }\n  }, {\n    key: \"_hide\",\n    value: function _hide()\n    /* reference, options */\n    {\n      var _this6 = this;\n\n      // don't hide if it's already hidden\n      if (!this._isOpen) {\n        return this;\n      }\n\n      this._isOpen = false;\n\n      this._noLongerOpen(); // hide tooltipNode\n\n\n      this._tooltipNode.style.display = 'none';\n\n      this._tooltipNode.setAttribute('aria-hidden', 'true');\n\n      if (this.popperInstance) {\n        this.popperInstance.disableEventListeners();\n      }\n\n      clearTimeout(this._disposeTimer);\n      var disposeTime = directive.options.disposeTimeout;\n\n      if (disposeTime !== null) {\n        this._disposeTimer = setTimeout(function () {\n          if (_this6._tooltipNode) {\n            _this6._tooltipNode.removeEventListener('mouseenter', _this6.hide);\n\n            _this6._tooltipNode.removeEventListener('click', _this6.hide); // Don't remove popper instance, just the HTML element\n\n\n            _this6._removeTooltipNode();\n          }\n        }, disposeTime);\n      }\n\n      removeClasses(this.reference, ['v-tooltip-open']);\n      return this;\n    }\n  }, {\n    key: \"_removeTooltipNode\",\n    value: function _removeTooltipNode() {\n      if (!this._tooltipNode) return;\n      var parentNode = this._tooltipNode.parentNode;\n\n      if (parentNode) {\n        parentNode.removeChild(this._tooltipNode);\n        this.reference.removeAttribute('aria-describedby');\n      }\n\n      this._tooltipNode = null;\n    }\n  }, {\n    key: \"_dispose\",\n    value: function _dispose() {\n      var _this7 = this;\n\n      this._isDisposed = true;\n      this.reference.removeAttribute('data-original-title');\n\n      if (this.$_originalTitle) {\n        this.reference.setAttribute('title', this.$_originalTitle);\n      } // remove event listeners first to prevent any unexpected behaviour\n\n\n      this._events.forEach(function (_ref) {\n        var func = _ref.func,\n            event = _ref.event;\n\n        _this7.reference.removeEventListener(event, func);\n      });\n\n      this._events = [];\n\n      if (this._tooltipNode) {\n        this._hide();\n\n        this._tooltipNode.removeEventListener('mouseenter', this.hide);\n\n        this._tooltipNode.removeEventListener('click', this.hide); // destroy instance\n\n\n        this.popperInstance.destroy(); // destroy tooltipNode if removeOnDestroy is not set, as popperInstance.destroy() already removes the element\n\n        if (!this.popperInstance.options.removeOnDestroy) {\n          this._removeTooltipNode();\n        }\n      } else {\n        this._noLongerOpen();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_findContainer\",\n    value: function _findContainer(container, reference) {\n      // if container is a query, get the relative element\n      if (typeof container === 'string') {\n        container = window.document.querySelector(container);\n      } else if (container === false) {\n        // if container is `false`, set it to reference parent\n        container = reference.parentNode;\n      }\n\n      return container;\n    }\n    /**\n     * Append tooltip to container\n     * @memberof Tooltip\n     * @private\n     * @param {HTMLElement} tooltip\n     * @param {HTMLElement|String|false} container\n     */\n\n  }, {\n    key: \"_append\",\n    value: function _append(tooltipNode, container) {\n      container.appendChild(tooltipNode);\n    }\n  }, {\n    key: \"_setEventListeners\",\n    value: function _setEventListeners(reference, events, options) {\n      var _this8 = this;\n\n      var directEvents = [];\n      var oppositeEvents = [];\n      events.forEach(function (event) {\n        switch (event) {\n          case 'hover':\n            directEvents.push('mouseenter');\n            oppositeEvents.push('mouseleave');\n            if (_this8.options.hideOnTargetClick) oppositeEvents.push('click');\n            break;\n\n          case 'focus':\n            directEvents.push('focus');\n            oppositeEvents.push('blur');\n            if (_this8.options.hideOnTargetClick) oppositeEvents.push('click');\n            break;\n\n          case 'click':\n            directEvents.push('click');\n            oppositeEvents.push('click');\n            break;\n        }\n      }); // schedule show tooltip\n\n      directEvents.forEach(function (event) {\n        var func = function func(evt) {\n          if (_this8._isOpen === true) {\n            return;\n          }\n\n          evt.usedByTooltip = true;\n\n          _this8._scheduleShow(reference, options.delay, options, evt);\n        };\n\n        _this8._events.push({\n          event: event,\n          func: func\n        });\n\n        reference.addEventListener(event, func);\n      }); // schedule hide tooltip\n\n      oppositeEvents.forEach(function (event) {\n        var func = function func(evt) {\n          if (evt.usedByTooltip === true) {\n            return;\n          }\n\n          _this8._scheduleHide(reference, options.delay, options, evt);\n        };\n\n        _this8._events.push({\n          event: event,\n          func: func\n        });\n\n        reference.addEventListener(event, func);\n      });\n    }\n  }, {\n    key: \"_onDocumentTouch\",\n    value: function _onDocumentTouch(event) {\n      if (this._enableDocumentTouch) {\n        this._scheduleHide(this.reference, this.options.delay, this.options, event);\n      }\n    }\n  }, {\n    key: \"_scheduleShow\",\n    value: function _scheduleShow(reference, delay, options\n    /*, evt */\n    ) {\n      var _this9 = this;\n\n      // defaults to 0\n      var computedDelay = delay && delay.show || delay || 0;\n      clearTimeout(this._scheduleTimer);\n      this._scheduleTimer = window.setTimeout(function () {\n        return _this9._show(reference, options);\n      }, computedDelay);\n    }\n  }, {\n    key: \"_scheduleHide\",\n    value: function _scheduleHide(reference, delay, options, evt) {\n      var _this10 = this;\n\n      // defaults to 0\n      var computedDelay = delay && delay.hide || delay || 0;\n      clearTimeout(this._scheduleTimer);\n      this._scheduleTimer = window.setTimeout(function () {\n        if (_this10._isOpen === false) {\n          return;\n        }\n\n        if (!_this10._tooltipNode.ownerDocument.body.contains(_this10._tooltipNode)) {\n          return;\n        } // if we are hiding because of a mouseleave, we must check that the new\n        // reference isn't the tooltip, because in this case we don't want to hide it\n\n\n        if (evt.type === 'mouseleave') {\n          var isSet = _this10._setTooltipNodeEvent(evt, reference, delay, options); // if we set the new event, don't hide the tooltip yet\n          // the new event will take care to hide it if necessary\n\n\n          if (isSet) {\n            return;\n          }\n        }\n\n        _this10._hide(reference, options);\n      }, computedDelay);\n    }\n  }]);\n\n  return Tooltip;\n}(); // Hide tooltips on touch devices\n\nif (typeof document !== 'undefined') {\n  document.addEventListener('touchstart', function (event) {\n    for (var i = 0; i < openTooltips.length; i++) {\n      openTooltips[i]._onDocumentTouch(event);\n    }\n  }, supportsPassive ? {\n    passive: true,\n    capture: true\n  } : true);\n}\n/**\n * Placement function, its context is the Tooltip instance.\n * @memberof Tooltip\n * @callback PlacementFunction\n * @param {HTMLElement} tooltip - tooltip DOM node.\n * @param {HTMLElement} reference - reference DOM node.\n * @return {String} placement - One of the allowed placement options.\n */\n\n/**\n * Title function, its context is the Tooltip instance.\n * @memberof Tooltip\n * @callback TitleFunction\n * @return {String} placement - The desired title.\n */\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar state = {\n  enabled: true\n};\nvar positions = ['top', 'top-start', 'top-end', 'right', 'right-start', 'right-end', 'bottom', 'bottom-start', 'bottom-end', 'left', 'left-start', 'left-end'];\nvar defaultOptions = {\n  // Default tooltip placement relative to target element\n  defaultPlacement: 'top',\n  // Default CSS classes applied to the tooltip element\n  defaultClass: 'vue-tooltip-theme',\n  // Default CSS classes applied to the target element of the tooltip\n  defaultTargetClass: 'has-tooltip',\n  // Is the content HTML by default?\n  defaultHtml: true,\n  // Default HTML template of the tooltip element\n  // It must include `tooltip-arrow` & `tooltip-inner` CSS classes (can be configured, see below)\n  // Change if the classes conflict with other libraries (for example bootstrap)\n  defaultTemplate: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n  // Selector used to get the arrow element in the tooltip template\n  defaultArrowSelector: '.tooltip-arrow, .tooltip__arrow',\n  // Selector used to get the inner content element in the tooltip template\n  defaultInnerSelector: '.tooltip-inner, .tooltip__inner',\n  // Delay (ms)\n  defaultDelay: 0,\n  // Default events that trigger the tooltip\n  defaultTrigger: 'hover focus',\n  // Default position offset (px)\n  defaultOffset: 0,\n  // Default container where the tooltip will be appended\n  defaultContainer: 'body',\n  defaultBoundariesElement: undefined,\n  defaultPopperOptions: {},\n  // Class added when content is loading\n  defaultLoadingClass: 'tooltip-loading',\n  // Displayed when tooltip content is loading\n  defaultLoadingContent: '...',\n  // Hide on mouseover tooltip\n  autoHide: true,\n  // Close tooltip on click on tooltip target?\n  defaultHideOnTargetClick: true,\n  // Auto destroy tooltip DOM nodes (ms)\n  disposeTimeout: 5000,\n  // Options for popover\n  popover: {\n    defaultPlacement: 'bottom',\n    // Use the `popoverClass` prop for theming\n    defaultClass: 'vue-popover-theme',\n    // Base class (change if conflicts with other libraries)\n    defaultBaseClass: 'tooltip popover',\n    // Wrapper class (contains arrow and inner)\n    defaultWrapperClass: 'wrapper',\n    // Inner content class\n    defaultInnerClass: 'tooltip-inner popover-inner',\n    // Arrow class\n    defaultArrowClass: 'tooltip-arrow popover-arrow',\n    // Class added when popover is open\n    defaultOpenClass: 'open',\n    defaultDelay: 0,\n    defaultTrigger: 'click',\n    defaultOffset: 0,\n    defaultContainer: 'body',\n    defaultBoundariesElement: undefined,\n    defaultPopperOptions: {},\n    // Hides if clicked outside of popover\n    defaultAutoHide: true,\n    // Update popper on content resize\n    defaultHandleResize: true\n  }\n};\nfunction getOptions(options) {\n  var result = {\n    placement: typeof options.placement !== 'undefined' ? options.placement : directive.options.defaultPlacement,\n    delay: typeof options.delay !== 'undefined' ? options.delay : directive.options.defaultDelay,\n    html: typeof options.html !== 'undefined' ? options.html : directive.options.defaultHtml,\n    template: typeof options.template !== 'undefined' ? options.template : directive.options.defaultTemplate,\n    arrowSelector: typeof options.arrowSelector !== 'undefined' ? options.arrowSelector : directive.options.defaultArrowSelector,\n    innerSelector: typeof options.innerSelector !== 'undefined' ? options.innerSelector : directive.options.defaultInnerSelector,\n    trigger: typeof options.trigger !== 'undefined' ? options.trigger : directive.options.defaultTrigger,\n    offset: typeof options.offset !== 'undefined' ? options.offset : directive.options.defaultOffset,\n    container: typeof options.container !== 'undefined' ? options.container : directive.options.defaultContainer,\n    boundariesElement: typeof options.boundariesElement !== 'undefined' ? options.boundariesElement : directive.options.defaultBoundariesElement,\n    autoHide: typeof options.autoHide !== 'undefined' ? options.autoHide : directive.options.autoHide,\n    hideOnTargetClick: typeof options.hideOnTargetClick !== 'undefined' ? options.hideOnTargetClick : directive.options.defaultHideOnTargetClick,\n    loadingClass: typeof options.loadingClass !== 'undefined' ? options.loadingClass : directive.options.defaultLoadingClass,\n    loadingContent: typeof options.loadingContent !== 'undefined' ? options.loadingContent : directive.options.defaultLoadingContent,\n    popperOptions: _objectSpread$1({}, typeof options.popperOptions !== 'undefined' ? options.popperOptions : directive.options.defaultPopperOptions)\n  };\n\n  if (result.offset) {\n    var typeofOffset = (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__.default)(result.offset);\n\n    var offset = result.offset; // One value -> switch\n\n    if (typeofOffset === 'number' || typeofOffset === 'string' && offset.indexOf(',') === -1) {\n      offset = \"0, \".concat(offset);\n    }\n\n    if (!result.popperOptions.modifiers) {\n      result.popperOptions.modifiers = {};\n    }\n\n    result.popperOptions.modifiers.offset = {\n      offset: offset\n    };\n  }\n\n  if (result.trigger && result.trigger.indexOf('click') !== -1) {\n    result.hideOnTargetClick = false;\n  }\n\n  return result;\n}\nfunction getPlacement(value, modifiers) {\n  var placement = value.placement;\n\n  for (var i = 0; i < positions.length; i++) {\n    var pos = positions[i];\n\n    if (modifiers[pos]) {\n      placement = pos;\n    }\n  }\n\n  return placement;\n}\nfunction getContent(value) {\n  var type = (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__.default)(value);\n\n  if (type === 'string') {\n    return value;\n  } else if (value && type === 'object') {\n    return value.content;\n  } else {\n    return false;\n  }\n}\nfunction createTooltip(el, value) {\n  var modifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var content = getContent(value);\n  var classes = typeof value.classes !== 'undefined' ? value.classes : directive.options.defaultClass;\n\n  var opts = _objectSpread$1({\n    title: content\n  }, getOptions(_objectSpread$1(_objectSpread$1({}, (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__.default)(value) === 'object' ? value : {}), {}, {\n    placement: getPlacement(value, modifiers)\n  })));\n\n  var tooltip = el._tooltip = new Tooltip(el, opts);\n  tooltip.setClasses(classes);\n  tooltip._vueEl = el; // Class on target\n\n  var targetClasses = typeof value.targetClasses !== 'undefined' ? value.targetClasses : directive.options.defaultTargetClass;\n  el._tooltipTargetClasses = targetClasses;\n  addClasses(el, targetClasses);\n  return tooltip;\n}\nfunction destroyTooltip(el) {\n  if (el._tooltip) {\n    el._tooltip.dispose();\n\n    delete el._tooltip;\n    delete el._tooltipOldShow;\n  }\n\n  if (el._tooltipTargetClasses) {\n    removeClasses(el, el._tooltipTargetClasses);\n    delete el._tooltipTargetClasses;\n  }\n}\nfunction bind(el, _ref) {\n  var value = _ref.value;\n      _ref.oldValue;\n      var modifiers = _ref.modifiers;\n  var content = getContent(value);\n\n  if (!content || !state.enabled) {\n    destroyTooltip(el);\n  } else {\n    var tooltip;\n\n    if (el._tooltip) {\n      tooltip = el._tooltip; // Content\n\n      tooltip.setContent(content); // Options\n\n      tooltip.setOptions(_objectSpread$1(_objectSpread$1({}, value), {}, {\n        placement: getPlacement(value, modifiers)\n      }));\n    } else {\n      tooltip = createTooltip(el, value, modifiers);\n    } // Manual show\n\n\n    if (typeof value.show !== 'undefined' && value.show !== el._tooltipOldShow) {\n      el._tooltipOldShow = value.show;\n      value.show ? tooltip.show() : tooltip.hide();\n    }\n  }\n}\nvar directive = {\n  options: defaultOptions,\n  bind: bind,\n  update: bind,\n  unbind: function unbind(el) {\n    destroyTooltip(el);\n  }\n};\n\nfunction addListeners(el) {\n  el.addEventListener('click', onClick);\n  el.addEventListener('touchstart', onTouchStart, supportsPassive ? {\n    passive: true\n  } : false);\n}\n\nfunction removeListeners(el) {\n  el.removeEventListener('click', onClick);\n  el.removeEventListener('touchstart', onTouchStart);\n  el.removeEventListener('touchend', onTouchEnd);\n  el.removeEventListener('touchcancel', onTouchCancel);\n}\n\nfunction onClick(event) {\n  var el = event.currentTarget;\n  event.closePopover = !el.$_vclosepopover_touch;\n  event.closeAllPopover = el.$_closePopoverModifiers && !!el.$_closePopoverModifiers.all;\n}\n\nfunction onTouchStart(event) {\n  if (event.changedTouches.length === 1) {\n    var el = event.currentTarget;\n    el.$_vclosepopover_touch = true;\n    var touch = event.changedTouches[0];\n    el.$_vclosepopover_touchPoint = touch;\n    el.addEventListener('touchend', onTouchEnd);\n    el.addEventListener('touchcancel', onTouchCancel);\n  }\n}\n\nfunction onTouchEnd(event) {\n  var el = event.currentTarget;\n  el.$_vclosepopover_touch = false;\n\n  if (event.changedTouches.length === 1) {\n    var touch = event.changedTouches[0];\n    var firstTouch = el.$_vclosepopover_touchPoint;\n    event.closePopover = Math.abs(touch.screenY - firstTouch.screenY) < 20 && Math.abs(touch.screenX - firstTouch.screenX) < 20;\n    event.closeAllPopover = el.$_closePopoverModifiers && !!el.$_closePopoverModifiers.all;\n  }\n}\n\nfunction onTouchCancel(event) {\n  var el = event.currentTarget;\n  el.$_vclosepopover_touch = false;\n}\n\nvar vclosepopover = {\n  bind: function bind(el, _ref) {\n    var value = _ref.value,\n        modifiers = _ref.modifiers;\n    el.$_closePopoverModifiers = modifiers;\n\n    if (typeof value === 'undefined' || value) {\n      addListeners(el);\n    }\n  },\n  update: function update(el, _ref2) {\n    var value = _ref2.value,\n        oldValue = _ref2.oldValue,\n        modifiers = _ref2.modifiers;\n    el.$_closePopoverModifiers = modifiers;\n\n    if (value !== oldValue) {\n      if (typeof value === 'undefined' || value) {\n        addListeners(el);\n      } else {\n        removeListeners(el);\n      }\n    }\n  },\n  unbind: function unbind(el) {\n    removeListeners(el);\n  }\n};\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction getDefault(key) {\n  var value = directive.options.popover[key];\n\n  if (typeof value === 'undefined') {\n    return directive.options[key];\n  }\n\n  return value;\n}\n\nvar isIOS = false;\n\nif (typeof window !== 'undefined' && typeof navigator !== 'undefined') {\n  isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n}\n\nvar openPopovers = [];\n\nvar Element = function Element() {};\n\nif (typeof window !== 'undefined') {\n  Element = window.Element;\n}\n\nvar script = {\n  name: 'VPopover',\n  components: {\n    ResizeObserver: vue_resize__WEBPACK_IMPORTED_MODULE_5__.ResizeObserver\n  },\n  props: {\n    open: {\n      type: Boolean,\n      default: false\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    placement: {\n      type: String,\n      default: function _default() {\n        return getDefault('defaultPlacement');\n      }\n    },\n    delay: {\n      type: [String, Number, Object],\n      default: function _default() {\n        return getDefault('defaultDelay');\n      }\n    },\n    offset: {\n      type: [String, Number],\n      default: function _default() {\n        return getDefault('defaultOffset');\n      }\n    },\n    trigger: {\n      type: String,\n      default: function _default() {\n        return getDefault('defaultTrigger');\n      }\n    },\n    container: {\n      type: [String, Object, Element, Boolean],\n      default: function _default() {\n        return getDefault('defaultContainer');\n      }\n    },\n    boundariesElement: {\n      type: [String, Element],\n      default: function _default() {\n        return getDefault('defaultBoundariesElement');\n      }\n    },\n    popperOptions: {\n      type: Object,\n      default: function _default() {\n        return getDefault('defaultPopperOptions');\n      }\n    },\n    popoverClass: {\n      type: [String, Array],\n      default: function _default() {\n        return getDefault('defaultClass');\n      }\n    },\n    popoverBaseClass: {\n      type: [String, Array],\n      default: function _default() {\n        return directive.options.popover.defaultBaseClass;\n      }\n    },\n    popoverInnerClass: {\n      type: [String, Array],\n      default: function _default() {\n        return directive.options.popover.defaultInnerClass;\n      }\n    },\n    popoverWrapperClass: {\n      type: [String, Array],\n      default: function _default() {\n        return directive.options.popover.defaultWrapperClass;\n      }\n    },\n    popoverArrowClass: {\n      type: [String, Array],\n      default: function _default() {\n        return directive.options.popover.defaultArrowClass;\n      }\n    },\n    autoHide: {\n      type: Boolean,\n      default: function _default() {\n        return directive.options.popover.defaultAutoHide;\n      }\n    },\n    handleResize: {\n      type: Boolean,\n      default: function _default() {\n        return directive.options.popover.defaultHandleResize;\n      }\n    },\n    openGroup: {\n      type: String,\n      default: null\n    },\n    openClass: {\n      type: [String, Array],\n      default: function _default() {\n        return directive.options.popover.defaultOpenClass;\n      }\n    },\n    ariaId: {\n      default: null\n    }\n  },\n  data: function data() {\n    return {\n      isOpen: false,\n      id: Math.random().toString(36).substr(2, 10)\n    };\n  },\n  computed: {\n    cssClass: function cssClass() {\n      return (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__.default)({}, this.openClass, this.isOpen);\n    },\n    popoverId: function popoverId() {\n      return \"popover_\".concat(this.ariaId != null ? this.ariaId : this.id);\n    }\n  },\n  watch: {\n    open: function open(val) {\n      if (val) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    },\n    disabled: function disabled(val, oldVal) {\n      if (val !== oldVal) {\n        if (val) {\n          this.hide();\n        } else if (this.open) {\n          this.show();\n        }\n      }\n    },\n    container: function container(val) {\n      if (this.isOpen && this.popperInstance) {\n        var popoverNode = this.$refs.popover;\n        var reference = this.$refs.trigger;\n        var container = this.$_findContainer(this.container, reference);\n\n        if (!container) {\n          console.warn('No container for popover', this);\n          return;\n        }\n\n        container.appendChild(popoverNode);\n        this.popperInstance.scheduleUpdate();\n      }\n    },\n    trigger: function trigger(val) {\n      this.$_removeEventListeners();\n      this.$_addEventListeners();\n    },\n    placement: function placement(val) {\n      var _this = this;\n\n      this.$_updatePopper(function () {\n        _this.popperInstance.options.placement = val;\n      });\n    },\n    offset: '$_restartPopper',\n    boundariesElement: '$_restartPopper',\n    popperOptions: {\n      handler: '$_restartPopper',\n      deep: true\n    }\n  },\n  created: function created() {\n    this.$_isDisposed = false;\n    this.$_mounted = false;\n    this.$_events = [];\n    this.$_preventOpen = false;\n  },\n  mounted: function mounted() {\n    var popoverNode = this.$refs.popover;\n    popoverNode.parentNode && popoverNode.parentNode.removeChild(popoverNode);\n    this.$_init();\n\n    if (this.open) {\n      this.show();\n    }\n  },\n  deactivated: function deactivated() {\n    this.hide();\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.dispose();\n  },\n  methods: {\n    show: function show() {\n      var _this2 = this;\n\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          event = _ref2.event;\n          _ref2.skipDelay;\n          var _ref2$force = _ref2.force,\n          force = _ref2$force === void 0 ? false : _ref2$force;\n\n      if (force || !this.disabled) {\n        this.$_scheduleShow(event);\n        this.$emit('show');\n      }\n\n      this.$emit('update:open', true);\n      this.$_beingShowed = true;\n      requestAnimationFrame(function () {\n        _this2.$_beingShowed = false;\n      });\n    },\n    hide: function hide() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          event = _ref3.event;\n          _ref3.skipDelay;\n\n      this.$_scheduleHide(event);\n      this.$emit('hide');\n      this.$emit('update:open', false);\n    },\n    dispose: function dispose() {\n      this.$_isDisposed = true;\n      this.$_removeEventListeners();\n      this.hide({\n        skipDelay: true\n      });\n\n      if (this.popperInstance) {\n        this.popperInstance.destroy(); // destroy tooltipNode if removeOnDestroy is not set, as popperInstance.destroy() already removes the element\n\n        if (!this.popperInstance.options.removeOnDestroy) {\n          var popoverNode = this.$refs.popover;\n          popoverNode.parentNode && popoverNode.parentNode.removeChild(popoverNode);\n        }\n      }\n\n      this.$_mounted = false;\n      this.popperInstance = null;\n      this.isOpen = false;\n      this.$emit('dispose');\n    },\n    $_init: function $_init() {\n      if (this.trigger.indexOf('manual') === -1) {\n        this.$_addEventListeners();\n      }\n    },\n    $_show: function $_show() {\n      var _this3 = this;\n\n      var reference = this.$refs.trigger;\n      var popoverNode = this.$refs.popover;\n      clearTimeout(this.$_disposeTimer); // Already open\n\n      if (this.isOpen) {\n        return;\n      } // Popper is already initialized\n\n\n      if (this.popperInstance) {\n        this.isOpen = true;\n        this.popperInstance.enableEventListeners();\n        this.popperInstance.scheduleUpdate();\n      }\n\n      if (!this.$_mounted) {\n        var container = this.$_findContainer(this.container, reference);\n\n        if (!container) {\n          console.warn('No container for popover', this);\n          return;\n        }\n\n        container.appendChild(popoverNode);\n        this.$_mounted = true;\n        this.isOpen = false;\n\n        if (this.popperInstance) {\n          requestAnimationFrame(function () {\n            if (!_this3.hidden) {\n              _this3.isOpen = true;\n            }\n          });\n        }\n      }\n\n      if (!this.popperInstance) {\n        var popperOptions = _objectSpread(_objectSpread({}, this.popperOptions), {}, {\n          placement: this.placement\n        });\n\n        popperOptions.modifiers = _objectSpread(_objectSpread({}, popperOptions.modifiers), {}, {\n          arrow: _objectSpread(_objectSpread({}, popperOptions.modifiers && popperOptions.modifiers.arrow), {}, {\n            element: this.$refs.arrow\n          })\n        });\n\n        if (this.offset) {\n          var offset = this.$_getOffset();\n          popperOptions.modifiers.offset = _objectSpread(_objectSpread({}, popperOptions.modifiers && popperOptions.modifiers.offset), {}, {\n            offset: offset\n          });\n        }\n\n        if (this.boundariesElement) {\n          popperOptions.modifiers.preventOverflow = _objectSpread(_objectSpread({}, popperOptions.modifiers && popperOptions.modifiers.preventOverflow), {}, {\n            boundariesElement: this.boundariesElement\n          });\n        }\n\n        this.popperInstance = new popper_js__WEBPACK_IMPORTED_MODULE_7__.default(reference, popoverNode, popperOptions); // Fix position\n\n        requestAnimationFrame(function () {\n          if (_this3.hidden) {\n            _this3.hidden = false;\n\n            _this3.$_hide();\n\n            return;\n          }\n\n          if (!_this3.$_isDisposed && _this3.popperInstance) {\n            _this3.popperInstance.scheduleUpdate(); // Show the tooltip\n\n\n            requestAnimationFrame(function () {\n              if (_this3.hidden) {\n                _this3.hidden = false;\n\n                _this3.$_hide();\n\n                return;\n              }\n\n              if (!_this3.$_isDisposed) {\n                _this3.isOpen = true;\n              } else {\n                _this3.dispose();\n              }\n            });\n          } else {\n            _this3.dispose();\n          }\n        });\n      }\n\n      var openGroup = this.openGroup;\n\n      if (openGroup) {\n        var popover;\n\n        for (var i = 0; i < openPopovers.length; i++) {\n          popover = openPopovers[i];\n\n          if (popover.openGroup !== openGroup) {\n            popover.hide();\n            popover.$emit('close-group');\n          }\n        }\n      }\n\n      openPopovers.push(this);\n      this.$emit('apply-show');\n    },\n    $_hide: function $_hide() {\n      var _this4 = this;\n\n      // Already hidden\n      if (!this.isOpen) {\n        return;\n      }\n\n      var index = openPopovers.indexOf(this);\n\n      if (index !== -1) {\n        openPopovers.splice(index, 1);\n      }\n\n      this.isOpen = false;\n\n      if (this.popperInstance) {\n        this.popperInstance.disableEventListeners();\n      }\n\n      clearTimeout(this.$_disposeTimer);\n      var disposeTime = directive.options.popover.disposeTimeout || directive.options.disposeTimeout;\n\n      if (disposeTime !== null) {\n        this.$_disposeTimer = setTimeout(function () {\n          var popoverNode = _this4.$refs.popover;\n\n          if (popoverNode) {\n            // Don't remove popper instance, just the HTML element\n            popoverNode.parentNode && popoverNode.parentNode.removeChild(popoverNode);\n            _this4.$_mounted = false;\n          }\n        }, disposeTime);\n      }\n\n      this.$emit('apply-hide');\n    },\n    $_findContainer: function $_findContainer(container, reference) {\n      // if container is a query, get the relative element\n      if (typeof container === 'string') {\n        container = window.document.querySelector(container);\n      } else if (container === false) {\n        // if container is `false`, set it to reference parent\n        container = reference.parentNode;\n      }\n\n      return container;\n    },\n    $_getOffset: function $_getOffset() {\n      var typeofOffset = (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__.default)(this.offset);\n\n      var offset = this.offset; // One value -> switch\n\n      if (typeofOffset === 'number' || typeofOffset === 'string' && offset.indexOf(',') === -1) {\n        offset = \"0, \".concat(offset);\n      }\n\n      return offset;\n    },\n    $_addEventListeners: function $_addEventListeners() {\n      var _this5 = this;\n\n      var reference = this.$refs.trigger;\n      var directEvents = [];\n      var oppositeEvents = [];\n      var events = typeof this.trigger === 'string' ? this.trigger.split(' ').filter(function (trigger) {\n        return ['click', 'hover', 'focus'].indexOf(trigger) !== -1;\n      }) : [];\n      events.forEach(function (event) {\n        switch (event) {\n          case 'hover':\n            directEvents.push('mouseenter');\n            oppositeEvents.push('mouseleave');\n            break;\n\n          case 'focus':\n            directEvents.push('focus');\n            oppositeEvents.push('blur');\n            break;\n\n          case 'click':\n            directEvents.push('click');\n            oppositeEvents.push('click');\n            break;\n        }\n      }); // schedule show tooltip\n\n      directEvents.forEach(function (event) {\n        var func = function func(event) {\n          if (_this5.isOpen) {\n            return;\n          }\n\n          event.usedByTooltip = true;\n          !_this5.$_preventOpen && _this5.show({\n            event: event\n          });\n          _this5.hidden = false;\n        };\n\n        _this5.$_events.push({\n          event: event,\n          func: func\n        });\n\n        reference.addEventListener(event, func);\n      }); // schedule hide tooltip\n\n      oppositeEvents.forEach(function (event) {\n        var func = function func(event) {\n          if (event.usedByTooltip) {\n            return;\n          }\n\n          _this5.hide({\n            event: event\n          });\n\n          _this5.hidden = true;\n        };\n\n        _this5.$_events.push({\n          event: event,\n          func: func\n        });\n\n        reference.addEventListener(event, func);\n      });\n    },\n    $_scheduleShow: function $_scheduleShow() {\n      var skipDelay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      clearTimeout(this.$_scheduleTimer);\n\n      if (skipDelay) {\n        this.$_show();\n      } else {\n        // defaults to 0\n        var computedDelay = parseInt(this.delay && this.delay.show || this.delay || 0);\n        this.$_scheduleTimer = setTimeout(this.$_show.bind(this), computedDelay);\n      }\n    },\n    $_scheduleHide: function $_scheduleHide() {\n      var _this6 = this;\n\n      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var skipDelay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      clearTimeout(this.$_scheduleTimer);\n\n      if (skipDelay) {\n        this.$_hide();\n      } else {\n        // defaults to 0\n        var computedDelay = parseInt(this.delay && this.delay.hide || this.delay || 0);\n        this.$_scheduleTimer = setTimeout(function () {\n          if (!_this6.isOpen) {\n            return;\n          } // if we are hiding because of a mouseleave, we must check that the new\n          // reference isn't the tooltip, because in this case we don't want to hide it\n\n\n          if (event && event.type === 'mouseleave') {\n            var isSet = _this6.$_setTooltipNodeEvent(event); // if we set the new event, don't hide the tooltip yet\n            // the new event will take care to hide it if necessary\n\n\n            if (isSet) {\n              return;\n            }\n          }\n\n          _this6.$_hide();\n        }, computedDelay);\n      }\n    },\n    $_setTooltipNodeEvent: function $_setTooltipNodeEvent(event) {\n      var _this7 = this;\n\n      var reference = this.$refs.trigger;\n      var popoverNode = this.$refs.popover;\n      var relatedreference = event.relatedreference || event.toElement || event.relatedTarget;\n\n      var callback = function callback(event2) {\n        var relatedreference2 = event2.relatedreference || event2.toElement || event2.relatedTarget; // Remove event listener after call\n\n        popoverNode.removeEventListener(event.type, callback); // If the new reference is not the reference element\n\n        if (!reference.contains(relatedreference2)) {\n          // Schedule to hide tooltip\n          _this7.hide({\n            event: event2\n          });\n        }\n      };\n\n      if (popoverNode.contains(relatedreference)) {\n        // listen to mouseleave on the tooltip element to be able to hide the tooltip\n        popoverNode.addEventListener(event.type, callback);\n        return true;\n      }\n\n      return false;\n    },\n    $_removeEventListeners: function $_removeEventListeners() {\n      var reference = this.$refs.trigger;\n      this.$_events.forEach(function (_ref4) {\n        var func = _ref4.func,\n            event = _ref4.event;\n        reference.removeEventListener(event, func);\n      });\n      this.$_events = [];\n    },\n    $_updatePopper: function $_updatePopper(cb) {\n      if (this.popperInstance) {\n        cb();\n        if (this.isOpen) this.popperInstance.scheduleUpdate();\n      }\n    },\n    $_restartPopper: function $_restartPopper() {\n      if (this.popperInstance) {\n        var isOpen = this.isOpen;\n        this.dispose();\n        this.$_isDisposed = false;\n        this.$_init();\n\n        if (isOpen) {\n          this.show({\n            skipDelay: true,\n            force: true\n          });\n        }\n      }\n    },\n    $_handleGlobalClose: function $_handleGlobalClose(event) {\n      var _this8 = this;\n\n      var touch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (this.$_beingShowed) return;\n      this.hide({\n        event: event\n      });\n\n      if (event.closePopover) {\n        this.$emit('close-directive');\n      } else {\n        this.$emit('auto-hide');\n      }\n\n      if (touch) {\n        this.$_preventOpen = true;\n        setTimeout(function () {\n          _this8.$_preventOpen = false;\n        }, 300);\n      }\n    },\n    $_handleResize: function $_handleResize() {\n      if (this.isOpen && this.popperInstance) {\n        this.popperInstance.scheduleUpdate();\n        this.$emit('resize');\n      }\n    }\n  }\n};\n\nif (typeof document !== 'undefined' && typeof window !== 'undefined') {\n  if (isIOS) {\n    document.addEventListener('touchend', handleGlobalTouchend, supportsPassive ? {\n      passive: true,\n      capture: true\n    } : true);\n  } else {\n    window.addEventListener('click', handleGlobalClick, true);\n  }\n}\n\nfunction handleGlobalClick(event) {\n  handleGlobalClose(event);\n}\n\nfunction handleGlobalTouchend(event) {\n  handleGlobalClose(event, true);\n}\n\nfunction handleGlobalClose(event) {\n  var touch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var _loop = function _loop(i) {\n    var popover = openPopovers[i];\n\n    if (popover.$refs.popover) {\n      var contains = popover.$refs.popover.contains(event.target);\n      requestAnimationFrame(function () {\n        if (event.closeAllPopover || event.closePopover && contains || popover.autoHide && !contains) {\n          popover.$_handleGlobalClose(event, touch);\n        }\n      });\n    }\n  };\n\n  // Delay so that close directive has time to set values\n  for (var i = 0; i < openPopovers.length; i++) {\n    _loop(i);\n  }\n}\n\nfunction normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\r\n    if (typeof shadowMode !== 'boolean') {\r\n        createInjectorSSR = createInjector;\r\n        createInjector = shadowMode;\r\n        shadowMode = false;\r\n    }\r\n    // Vue.extend constructor export interop.\r\n    const options = typeof script === 'function' ? script.options : script;\r\n    // render functions\r\n    if (template && template.render) {\r\n        options.render = template.render;\r\n        options.staticRenderFns = template.staticRenderFns;\r\n        options._compiled = true;\r\n        // functional template\r\n        if (isFunctionalTemplate) {\r\n            options.functional = true;\r\n        }\r\n    }\r\n    // scopedId\r\n    if (scopeId) {\r\n        options._scopeId = scopeId;\r\n    }\r\n    let hook;\r\n    if (moduleIdentifier) {\r\n        // server build\r\n        hook = function (context) {\r\n            // 2.3 injection\r\n            context =\r\n                context || // cached call\r\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\r\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\r\n            // 2.2 with runInNewContext: true\r\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n                context = __VUE_SSR_CONTEXT__;\r\n            }\r\n            // inject component styles\r\n            if (style) {\r\n                style.call(this, createInjectorSSR(context));\r\n            }\r\n            // register component module identifier for async chunk inference\r\n            if (context && context._registeredComponents) {\r\n                context._registeredComponents.add(moduleIdentifier);\r\n            }\r\n        };\r\n        // used by ssr in case component is cached and beforeCreate\r\n        // never gets called\r\n        options._ssrRegister = hook;\r\n    }\r\n    else if (style) {\r\n        hook = shadowMode\r\n            ? function (context) {\r\n                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));\r\n            }\r\n            : function (context) {\r\n                style.call(this, createInjector(context));\r\n            };\r\n    }\r\n    if (hook) {\r\n        if (options.functional) {\r\n            // register for functional component in vue file\r\n            const originalRender = options.render;\r\n            options.render = function renderWithStyleInjection(h, context) {\r\n                hook.call(context);\r\n                return originalRender(h, context);\r\n            };\r\n        }\r\n        else {\r\n            // inject component registration as beforeCreate hook\r\n            const existing = options.beforeCreate;\r\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\r\n        }\r\n    }\r\n    return script;\r\n}\n\n/* script */\nvar __vue_script__ = script;\n/* template */\n\nvar __vue_render__ = function __vue_render__() {\n  var _vm = this;\n\n  var _h = _vm.$createElement;\n\n  var _c = _vm._self._c || _h;\n\n  return _c(\"div\", {\n    staticClass: \"v-popover\",\n    class: _vm.cssClass\n  }, [_c(\"div\", {\n    ref: \"trigger\",\n    staticClass: \"trigger\",\n    staticStyle: {\n      display: \"inline-block\"\n    },\n    attrs: {\n      \"aria-describedby\": _vm.isOpen ? _vm.popoverId : undefined,\n      tabindex: _vm.trigger.indexOf(\"focus\") !== -1 ? 0 : undefined\n    }\n  }, [_vm._t(\"default\")], 2), _vm._v(\" \"), _c(\"div\", {\n    ref: \"popover\",\n    class: [_vm.popoverBaseClass, _vm.popoverClass, _vm.cssClass],\n    style: {\n      visibility: _vm.isOpen ? \"visible\" : \"hidden\"\n    },\n    attrs: {\n      id: _vm.popoverId,\n      \"aria-hidden\": _vm.isOpen ? \"false\" : \"true\",\n      tabindex: _vm.autoHide ? 0 : undefined\n    },\n    on: {\n      keyup: function keyup($event) {\n        if (!$event.type.indexOf(\"key\") && _vm._k($event.keyCode, \"esc\", 27, $event.key, [\"Esc\", \"Escape\"])) {\n          return null;\n        }\n\n        _vm.autoHide && _vm.hide();\n      }\n    }\n  }, [_c(\"div\", {\n    class: _vm.popoverWrapperClass\n  }, [_c(\"div\", {\n    ref: \"inner\",\n    class: _vm.popoverInnerClass,\n    staticStyle: {\n      position: \"relative\"\n    }\n  }, [_c(\"div\", [_vm._t(\"popover\", null, {\n    isOpen: _vm.isOpen\n  })], 2), _vm._v(\" \"), _vm.handleResize ? _c(\"ResizeObserver\", {\n    on: {\n      notify: _vm.$_handleResize\n    }\n  }) : _vm._e()], 1), _vm._v(\" \"), _c(\"div\", {\n    ref: \"arrow\",\n    class: _vm.popoverArrowClass\n  })])])]);\n};\n\nvar __vue_staticRenderFns__ = [];\n__vue_render__._withStripped = true;\n/* style */\n\nvar __vue_inject_styles__ = undefined;\n/* scoped */\n\nvar __vue_scope_id__ = undefined;\n/* module identifier */\n\nvar __vue_module_identifier__ = undefined;\n/* functional template */\n\nvar __vue_is_functional_template__ = false;\n/* style inject */\n\n/* style inject SSR */\n\n/* style inject shadow dom */\n\nvar __vue_component__ = /*#__PURE__*/normalizeComponent({\n  render: __vue_render__,\n  staticRenderFns: __vue_staticRenderFns__\n}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, undefined, undefined, undefined);\n\nfunction styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css_248z = \".resize-observer[data-v-8859cc6c]{position:absolute;top:0;left:0;z-index:-1;width:100%;height:100%;border:none;background-color:transparent;pointer-events:none;display:block;overflow:hidden;opacity:0}.resize-observer[data-v-8859cc6c] object{display:block;position:absolute;top:0;left:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1}\";\nstyleInject(css_248z);\n\nfunction install(Vue) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (install.installed) return;\n  install.installed = true;\n  var finalOptions = {};\n  lodash_merge__WEBPACK_IMPORTED_MODULE_6___default()(finalOptions, defaultOptions, options);\n  plugin.options = finalOptions;\n  directive.options = finalOptions;\n  Vue.directive('tooltip', directive);\n  Vue.directive('close-popover', vclosepopover);\n  Vue.component('VPopover', __vue_component__);\n}\nvar VTooltip = directive;\nvar VClosePopover = vclosepopover;\nvar VPopover = __vue_component__;\nvar plugin = {\n  install: install,\n\n  get enabled() {\n    return state.enabled;\n  },\n\n  set enabled(value) {\n    state.enabled = value;\n  }\n\n}; // Auto-install\n\nvar GlobalVue = null;\n\nif (typeof window !== 'undefined') {\n  GlobalVue = window.Vue;\n} else if (typeof __webpack_require__.g !== 'undefined') {\n  GlobalVue = __webpack_require__.g.Vue;\n}\n\nif (GlobalVue) {\n  GlobalVue.use(plugin);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (plugin);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdi10b29sdGlwL2Rpc3Qvdi10b29sdGlwLmVzbS5qcz9lMzdkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9EO0FBQ2dCO0FBQ0E7QUFDTjtBQUMvQjtBQUNNO0FBQ087QUFDWDs7QUFFakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsSUFBSTtBQUNmLFdBQVcsSUFBSTtBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsNENBQTRDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDhEQUE4RCxnRUFBZ0UsRUFBRSxFQUFFLGdDQUFnQyxFQUFFLGFBQWE7O0FBRXJWLGtDQUFrQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEseURBQXlELENBQUMsOEVBQWUsMkJBQTJCLEVBQUUsRUFBRSxFQUFFLDZDQUE2QywyRUFBMkUsRUFBRSxPQUFPLG1EQUFtRCxrRkFBa0YsRUFBRSxFQUFFLEVBQUUsRUFBRSxlQUFlO0FBQzFoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RCxhQUFhLFFBQVE7QUFDckIsYUFBYSx5QkFBeUI7QUFDdEMsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQ0FBaUM7QUFDOUMsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EseUNBQXlDO0FBQ3pDLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0EsYUFBYSxPQUFPLHlCQUF5QjtBQUM3QztBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBOztBQUVBLElBQUksOEVBQWU7O0FBRW5CLElBQUksOEVBQWU7O0FBRW5CLElBQUksOEVBQWU7QUFDbkI7O0FBRUE7QUFDQSw4RkFBOEY7O0FBRTlGLG1FQUFtRTs7O0FBR25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0EsNEJBQTRCOztBQUU1Qjs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsRUFBRSwyRUFBWTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxxREFBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sRUFBRTs7QUFFVCxvRUFBb0U7OztBQUdwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsT0FBTztBQUN0QixlQUFlLGlDQUFpQztBQUNoRCxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFlBQVk7QUFDNUI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7O0FBRXZELDBHQUEwRztBQUMxRztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87OztBQUdQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOzs7QUFHUCxtRUFBbUU7O0FBRW5FO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDs7QUFFQSxzQ0FBc0M7O0FBRXRDLGlFQUFpRTs7QUFFakU7O0FBRUE7O0FBRUEsNERBQTRELDRCQUE0QjtBQUN4RjtBQUNBLE9BQU87O0FBRVAsa0VBQWtFLDhCQUE4QjtBQUNoRztBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLDhDQUFNOztBQUV0Qyx1Q0FBdUM7OztBQUd2QztBQUNBO0FBQ0EseUNBQXlDOzs7QUFHekM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkI7OztBQUczQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwRUFBMEU7OztBQUcxRTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsa0VBQWtFOzs7QUFHbEUsc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLHlCQUF5QjtBQUN4Qzs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEVBQUU7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxPQUFPLEVBQUU7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7O0FBR0E7QUFDQSxtRkFBbUY7QUFDbkY7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUMsR0FBRzs7QUFFSjtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFlBQVk7QUFDdkIsWUFBWSxPQUFPO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25COztBQUVBLDRDQUE0QyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw4REFBOEQsZ0VBQWdFLEVBQUUsRUFBRSxnQ0FBZ0MsRUFBRSxhQUFhOztBQUVyVixrQ0FBa0MsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLHlEQUF5RCxDQUFDLDhFQUFlLDJCQUEyQixFQUFFLEVBQUUsRUFBRSw2Q0FBNkMsMkVBQTJFLEVBQUUsT0FBTyxtREFBbUQsa0ZBQWtGLEVBQUUsRUFBRSxFQUFFLEVBQUUsZUFBZTtBQUMxaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBLHVCQUF1QixzRUFBTzs7QUFFOUIsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0VBQU87O0FBRXBCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUcsK0NBQStDLEVBQUUsc0VBQU8saUNBQWlDLEtBQUs7QUFDakc7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSw0QkFBNEI7O0FBRTVCLGtDQUFrQzs7QUFFbEMsMkRBQTJELFlBQVk7QUFDdkU7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCw4REFBOEQsZ0VBQWdFLEVBQUUsRUFBRSxnQ0FBZ0MsRUFBRSxhQUFhOztBQUVuVixnQ0FBZ0MsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLHVEQUF1RCxDQUFDLDhFQUFlLDJCQUEyQixFQUFFLEVBQUUsRUFBRSw2Q0FBNkMsMkVBQTJFLEVBQUUsT0FBTyxpREFBaUQsa0ZBQWtGLEVBQUUsRUFBRSxFQUFFLEVBQUUsZUFBZTs7QUFFcGhCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQWM7QUFDbEMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEsOEVBQWUsR0FBRztBQUMvQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQseUJBQXlCO0FBQ25GO0FBQ0EsU0FBUzs7QUFFVCxnRUFBZ0UsOEJBQThCO0FBQzlGLCtDQUErQywrREFBK0Q7QUFDOUc7QUFDQSxXQUFXO0FBQ1gsU0FBUzs7QUFFVDtBQUNBO0FBQ0EseUVBQXlFLGdFQUFnRTtBQUN6STtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLGtGQUFrRix5RUFBeUU7QUFDM0o7QUFDQSxXQUFXO0FBQ1g7O0FBRUEsa0NBQWtDLDhDQUFNLHdDQUF3Qzs7QUFFaEY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7OztBQUduRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1QkFBdUIseUJBQXlCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHlCQUF5QixzRUFBTzs7QUFFaEMsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFQUFFOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLE9BQU8sRUFBRTs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOzs7QUFHQTtBQUNBLDREQUE0RDtBQUM1RDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxL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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLG1EQUFLO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyxpQkFBaUIscUJBQU07QUFDeEIsY0FBYyxxQkFBTTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsTUFBTSxFQUFDO0FBQytEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3YtdG9vbHRpcC9kaXN0L3YtdG9vbHRpcC5lc20uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX3R5cGVvZiBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZic7XG5pbXBvcnQgX2RlZmluZVByb3BlcnR5IGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHknO1xuaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrJztcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcyc7XG5pbXBvcnQgUG9wcGVyIGZyb20gJ3BvcHBlci5qcyc7XG5pbXBvcnQgaXNFcXVhbCBmcm9tICdsb2Rhc2gvaXNFcXVhbCc7XG5pbXBvcnQgeyBSZXNpemVPYnNlcnZlciB9IGZyb20gJ3Z1ZS1yZXNpemUnO1xuaW1wb3J0IG1lcmdlIGZyb20gJ2xvZGFzaC9tZXJnZSc7XG5cbnZhciBTVkdBbmltYXRlZFN0cmluZyA9IGZ1bmN0aW9uIFNWR0FuaW1hdGVkU3RyaW5nKCkge307XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBTVkdBbmltYXRlZFN0cmluZyA9IHdpbmRvdy5TVkdBbmltYXRlZFN0cmluZztcbn1cblxuZnVuY3Rpb24gY29udmVydFRvQXJyYXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCcgJyk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEFkZCBjbGFzc2VzIHRvIGFuIGVsZW1lbnQuXG4gKiBUaGlzIG1ldGhvZCBjaGVja3MgdG8gZW5zdXJlIHRoYXQgdGhlIGNsYXNzZXMgZG9uJ3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYWRkaW5nIHRoZW0uXG4gKiBJdCB1c2VzIGVsLmNsYXNzTmFtZSByYXRoZXIgdGhhbiBjbGFzc0xpc3QgaW4gb3JkZXIgdG8gYmUgSUUgZnJpZW5kbHkuXG4gKiBAcGFyYW0ge29iamVjdH0gZWwgLSBUaGUgZWxlbWVudCB0byBhZGQgdGhlIGNsYXNzZXMgdG8uXG4gKiBAcGFyYW0ge2NsYXNzZXN9IHN0cmluZyAtIExpc3Qgb2Ygc3BhY2Ugc2VwYXJhdGVkIGNsYXNzZXMgdG8gYmUgYWRkZWQgdG8gdGhlIGVsZW1lbnQuXG4gKi9cblxuZnVuY3Rpb24gYWRkQ2xhc3NlcyhlbCwgY2xhc3Nlcykge1xuICB2YXIgbmV3Q2xhc3NlcyA9IGNvbnZlcnRUb0FycmF5KGNsYXNzZXMpO1xuICB2YXIgY2xhc3NMaXN0O1xuXG4gIGlmIChlbC5jbGFzc05hbWUgaW5zdGFuY2VvZiBTVkdBbmltYXRlZFN0cmluZykge1xuICAgIGNsYXNzTGlzdCA9IGNvbnZlcnRUb0FycmF5KGVsLmNsYXNzTmFtZS5iYXNlVmFsKTtcbiAgfSBlbHNlIHtcbiAgICBjbGFzc0xpc3QgPSBjb252ZXJ0VG9BcnJheShlbC5jbGFzc05hbWUpO1xuICB9XG5cbiAgbmV3Q2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZXdDbGFzcykge1xuICAgIGlmIChjbGFzc0xpc3QuaW5kZXhPZihuZXdDbGFzcykgPT09IC0xKSB7XG4gICAgICBjbGFzc0xpc3QucHVzaChuZXdDbGFzcyk7XG4gICAgfVxuICB9KTtcblxuICBpZiAoZWwgaW5zdGFuY2VvZiBTVkdFbGVtZW50KSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNsYXNzTGlzdC5qb2luKCcgJykpO1xuICB9IGVsc2Uge1xuICAgIGVsLmNsYXNzTmFtZSA9IGNsYXNzTGlzdC5qb2luKCcgJyk7XG4gIH1cbn1cbi8qKlxuICogUmVtb3ZlIGNsYXNzZXMgZnJvbSBhbiBlbGVtZW50LlxuICogSXQgdXNlcyBlbC5jbGFzc05hbWUgcmF0aGVyIHRoYW4gY2xhc3NMaXN0IGluIG9yZGVyIHRvIGJlIElFIGZyaWVuZGx5LlxuICogQGV4cG9ydFxuICogQHBhcmFtIHthbnl9IGVsIFRoZSBlbGVtZW50IHRvIHJlbW92ZSB0aGUgY2xhc3NlcyBmcm9tLlxuICogQHBhcmFtIHthbnl9IGNsYXNzZXMgTGlzdCBvZiBzcGFjZSBzZXBhcmF0ZWQgY2xhc3NlcyB0byBiZSByZW1vdmVkIGZyb20gdGhlIGVsZW1lbnQuXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NlcyhlbCwgY2xhc3Nlcykge1xuICB2YXIgbmV3Q2xhc3NlcyA9IGNvbnZlcnRUb0FycmF5KGNsYXNzZXMpO1xuICB2YXIgY2xhc3NMaXN0O1xuXG4gIGlmIChlbC5jbGFzc05hbWUgaW5zdGFuY2VvZiBTVkdBbmltYXRlZFN0cmluZykge1xuICAgIGNsYXNzTGlzdCA9IGNvbnZlcnRUb0FycmF5KGVsLmNsYXNzTmFtZS5iYXNlVmFsKTtcbiAgfSBlbHNlIHtcbiAgICBjbGFzc0xpc3QgPSBjb252ZXJ0VG9BcnJheShlbC5jbGFzc05hbWUpO1xuICB9XG5cbiAgbmV3Q2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZXdDbGFzcykge1xuICAgIHZhciBpbmRleCA9IGNsYXNzTGlzdC5pbmRleE9mKG5ld0NsYXNzKTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGNsYXNzTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGVsIGluc3RhbmNlb2YgU1ZHRWxlbWVudCkge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbGFzc0xpc3Quam9pbignICcpKTtcbiAgfSBlbHNlIHtcbiAgICBlbC5jbGFzc05hbWUgPSBjbGFzc0xpc3Quam9pbignICcpO1xuICB9XG59XG52YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcblxuICB0cnkge1xuICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbmZ1bmN0aW9uIG93bktleXMkMihvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQyKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMihPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBjb250YWluZXI6IGZhbHNlLFxuICBkZWxheTogMCxcbiAgaHRtbDogZmFsc2UsXG4gIHBsYWNlbWVudDogJ3RvcCcsXG4gIHRpdGxlOiAnJyxcbiAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwidG9vbHRpcFwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBjbGFzcz1cInRvb2x0aXAtYXJyb3dcIj48L2Rpdj48ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiPjwvZGl2PjwvZGl2PicsXG4gIHRyaWdnZXI6ICdob3ZlciBmb2N1cycsXG4gIG9mZnNldDogMFxufTtcbnZhciBvcGVuVG9vbHRpcHMgPSBbXTtcblxudmFyIFRvb2x0aXAgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFRvb2x0aXAuanMgaW5zdGFuY2VcbiAgICogQGNsYXNzIFRvb2x0aXBcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlIC0gVGhlIERPTSBub2RlIHVzZWQgYXMgcmVmZXJlbmNlIG9mIHRoZSB0b29sdGlwIChpdCBjYW4gYmUgYSBqUXVlcnkgZWxlbWVudCkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnBsYWNlbWVudD1ib3R0b21cbiAgICogICAgICBQbGFjZW1lbnQgb2YgdGhlIHBvcHBlciBhY2NlcHRlZCB2YWx1ZXM6IGB0b3AoLXN0YXJ0LCAtZW5kKSwgcmlnaHQoLXN0YXJ0LCAtZW5kKSwgYm90dG9tKC1zdGFydCwgLWVuZCksXG4gICAqICAgICAgbGVmdCgtc3RhcnQsIC1lbmQpYFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fFN0cmluZ3xmYWxzZX0gb3B0aW9ucy5jb250YWluZXI9ZmFsc2UgLSBBcHBlbmQgdGhlIHRvb2x0aXAgdG8gYSBzcGVjaWZpYyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IG9wdGlvbnMuZGVsYXk9MFxuICAgKiAgICAgIERlbGF5IHNob3dpbmcgYW5kIGhpZGluZyB0aGUgdG9vbHRpcCAobXMpIC0gZG9lcyBub3QgYXBwbHkgdG8gbWFudWFsIHRyaWdnZXIgdHlwZS5cbiAgICogICAgICBJZiBhIG51bWJlciBpcyBzdXBwbGllZCwgZGVsYXkgaXMgYXBwbGllZCB0byBib3RoIGhpZGUvc2hvdy5cbiAgICogICAgICBPYmplY3Qgc3RydWN0dXJlIGlzOiBgeyBzaG93OiA1MDAsIGhpZGU6IDEwMCB9YFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuaHRtbD1mYWxzZSAtIEluc2VydCBIVE1MIGludG8gdGhlIHRvb2x0aXAuIElmIGZhbHNlLCB0aGUgY29udGVudCB3aWxsIGluc2VydGVkIHdpdGggYGlubmVyVGV4dGAuXG4gICAqIEBwYXJhbSB7U3RyaW5nfFBsYWNlbWVudEZ1bmN0aW9ufSBvcHRpb25zLnBsYWNlbWVudD0ndG9wJyAtIE9uZSBvZiB0aGUgYWxsb3dlZCBwbGFjZW1lbnRzLCBvciBhIGZ1bmN0aW9uIHJldHVybmluZyBvbmUgb2YgdGhlbS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRlbXBsYXRlPSc8ZGl2IGNsYXNzPVwidG9vbHRpcFwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBjbGFzcz1cInRvb2x0aXAtYXJyb3dcIj48L2Rpdj48ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiPjwvZGl2PjwvZGl2PiddXG4gICAqICAgICAgQmFzZSBIVE1MIHRvIHVzZWQgd2hlbiBjcmVhdGluZyB0aGUgdG9vbHRpcC5cbiAgICogICAgICBUaGUgdG9vbHRpcCdzIGB0aXRsZWAgd2lsbCBiZSBpbmplY3RlZCBpbnRvIHRoZSBgLnRvb2x0aXAtaW5uZXJgIG9yIGAudG9vbHRpcF9faW5uZXJgLlxuICAgKiAgICAgIGAudG9vbHRpcC1hcnJvd2Agb3IgYC50b29sdGlwX19hcnJvd2Agd2lsbCBiZWNvbWUgdGhlIHRvb2x0aXAncyBhcnJvdy5cbiAgICogICAgICBUaGUgb3V0ZXJtb3N0IHdyYXBwZXIgZWxlbWVudCBzaG91bGQgaGF2ZSB0aGUgYC50b29sdGlwYCBjbGFzcy5cbiAgICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR8VGl0bGVGdW5jdGlvbn0gb3B0aW9ucy50aXRsZT0nJyAtIERlZmF1bHQgdGl0bGUgdmFsdWUgaWYgYHRpdGxlYCBhdHRyaWJ1dGUgaXNuJ3QgcHJlc2VudC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRyaWdnZXI9J2hvdmVyIGZvY3VzJ11cbiAgICogICAgICBIb3cgdG9vbHRpcCBpcyB0cmlnZ2VyZWQgLSBjbGljaywgaG92ZXIsIGZvY3VzLCBtYW51YWwuXG4gICAqICAgICAgWW91IG1heSBwYXNzIG11bHRpcGxlIHRyaWdnZXJzOyBzZXBhcmF0ZSB0aGVtIHdpdGggYSBzcGFjZS4gYG1hbnVhbGAgY2Fubm90IGJlIGNvbWJpbmVkIHdpdGggYW55IG90aGVyIHRyaWdnZXIuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnRcbiAgICogICAgICBUaGUgZWxlbWVudCB1c2VkIGFzIGJvdW5kYXJpZXMgZm9yIHRoZSB0b29sdGlwLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiByZWZlciB0byBQb3BwZXIuanMnXG4gICAqICAgICAgW2JvdW5kYXJpZXNFbGVtZW50IGRvY3NdKGh0dHBzOi8vcG9wcGVyLmpzLm9yZy9wb3BwZXItZG9jdW1lbnRhdGlvbi5odG1sKVxuICAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IG9wdGlvbnMub2Zmc2V0PTAgLSBPZmZzZXQgb2YgdGhlIHRvb2x0aXAgcmVsYXRpdmUgdG8gaXRzIHJlZmVyZW5jZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24gcmVmZXIgdG8gUG9wcGVyLmpzJ1xuICAgKiAgICAgIFtvZmZzZXQgZG9jc10oaHR0cHM6Ly9wb3BwZXIuanMub3JnL3BvcHBlci1kb2N1bWVudGF0aW9uLmh0bWwpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnBvcHBlck9wdGlvbnM9e30gLSBQb3BwZXIgb3B0aW9ucywgd2lsbCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gcG9wcGVyIGluc3RhbmNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiByZWZlciB0byBQb3BwZXIuanMnXG4gICAqICAgICAgW29wdGlvbnMgZG9jc10oaHR0cHM6Ly9wb3BwZXIuanMub3JnL3BvcHBlci1kb2N1bWVudGF0aW9uLmh0bWwpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hcmlhSWRdIElkIHVzZWQgZm9yIGFjY2Vzc2liaWxpdHlcbiAgICogQHJldHVybiB7T2JqZWN0fSBpbnN0YW5jZSAtIFRoZSBnZW5lcmF0ZWQgdG9vbHRpcCBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gVG9vbHRpcChfcmVmZXJlbmNlLCBfb3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG9vbHRpcCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfZXZlbnRzXCIsIFtdKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zZXRUb29sdGlwTm9kZUV2ZW50XCIsIGZ1bmN0aW9uIChldnQsIHJlZmVyZW5jZSwgZGVsYXksIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWxhdGVkcmVmZXJlbmNlID0gZXZ0LnJlbGF0ZWRyZWZlcmVuY2UgfHwgZXZ0LnRvRWxlbWVudCB8fCBldnQucmVsYXRlZFRhcmdldDtcblxuICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soZXZ0Mikge1xuICAgICAgICB2YXIgcmVsYXRlZHJlZmVyZW5jZTIgPSBldnQyLnJlbGF0ZWRyZWZlcmVuY2UgfHwgZXZ0Mi50b0VsZW1lbnQgfHwgZXZ0Mi5yZWxhdGVkVGFyZ2V0OyAvLyBSZW1vdmUgZXZlbnQgbGlzdGVuZXIgYWZ0ZXIgY2FsbFxuXG4gICAgICAgIF90aGlzLl90b29sdGlwTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dC50eXBlLCBjYWxsYmFjayk7IC8vIElmIHRoZSBuZXcgcmVmZXJlbmNlIGlzIG5vdCB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcblxuXG4gICAgICAgIGlmICghcmVmZXJlbmNlLmNvbnRhaW5zKHJlbGF0ZWRyZWZlcmVuY2UyKSkge1xuICAgICAgICAgIC8vIFNjaGVkdWxlIHRvIGhpZGUgdG9vbHRpcFxuICAgICAgICAgIF90aGlzLl9zY2hlZHVsZUhpZGUocmVmZXJlbmNlLCBvcHRpb25zLmRlbGF5LCBvcHRpb25zLCBldnQyKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKF90aGlzLl90b29sdGlwTm9kZS5jb250YWlucyhyZWxhdGVkcmVmZXJlbmNlKSkge1xuICAgICAgICAvLyBsaXN0ZW4gdG8gbW91c2VsZWF2ZSBvbiB0aGUgdG9vbHRpcCBlbGVtZW50IHRvIGJlIGFibGUgdG8gaGlkZSB0aGUgdG9vbHRpcFxuICAgICAgICBfdGhpcy5fdG9vbHRpcE5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnQudHlwZSwgY2FsbGJhY2spO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG5cbiAgICAvLyBhcHBseSB1c2VyIG9wdGlvbnMgb3ZlciBkZWZhdWx0IG9uZXNcbiAgICBfb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQkMihfb2JqZWN0U3ByZWFkJDIoe30sIERFRkFVTFRfT1BUSU9OUyksIF9vcHRpb25zKTtcbiAgICBfcmVmZXJlbmNlLmpxdWVyeSAmJiAoX3JlZmVyZW5jZSA9IF9yZWZlcmVuY2VbMF0pO1xuICAgIHRoaXMuc2hvdyA9IHRoaXMuc2hvdy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGlkZSA9IHRoaXMuaGlkZS5iaW5kKHRoaXMpOyAvLyBjYWNoZSByZWZlcmVuY2UgYW5kIG9wdGlvbnNcblxuICAgIHRoaXMucmVmZXJlbmNlID0gX3JlZmVyZW5jZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBfb3B0aW9uczsgLy8gc2V0IGluaXRpYWwgc3RhdGVcblxuICAgIHRoaXMuX2lzT3BlbiA9IGZhbHNlO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuICB9IC8vXG4gIC8vIFB1YmxpYyBtZXRob2RzXG4gIC8vXG5cbiAgLyoqXG4gICAqIFJldmVhbHMgYW4gZWxlbWVudCdzIHRvb2x0aXAuIFRoaXMgaXMgY29uc2lkZXJlZCBhIFwibWFudWFsXCIgdHJpZ2dlcmluZyBvZiB0aGUgdG9vbHRpcC5cbiAgICogVG9vbHRpcHMgd2l0aCB6ZXJvLWxlbmd0aCB0aXRsZXMgYXJlIG5ldmVyIGRpc3BsYXllZC5cbiAgICogQG1ldGhvZCBUb29sdGlwI3Nob3dcbiAgICogQG1lbWJlcm9mIFRvb2x0aXBcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoVG9vbHRpcCwgW3tcbiAgICBrZXk6IFwic2hvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdGhpcy5fc2hvdyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZXMgYW4gZWxlbWVudOKAmXMgdG9vbHRpcC4gVGhpcyBpcyBjb25zaWRlcmVkIGEg4oCcbWFudWFs4oCdIHRyaWdnZXJpbmcgb2YgdGhlIHRvb2x0aXAuXG4gICAgICogQG1ldGhvZCBUb29sdGlwI2hpZGVcbiAgICAgKiBAbWVtYmVyb2YgVG9vbHRpcFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaGlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgdGhpcy5faGlkZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlcyBhbmQgZGVzdHJveXMgYW4gZWxlbWVudOKAmXMgdG9vbHRpcC5cbiAgICAgKiBAbWV0aG9kIFRvb2x0aXAjZGlzcG9zZVxuICAgICAqIEBtZW1iZXJvZiBUb29sdGlwXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICB0aGlzLl9kaXNwb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYW4gZWxlbWVudOKAmXMgdG9vbHRpcC4gVGhpcyBpcyBjb25zaWRlcmVkIGEg4oCcbWFudWFs4oCdIHRyaWdnZXJpbmcgb2YgdGhlIHRvb2x0aXAuXG4gICAgICogQG1ldGhvZCBUb29sdGlwI3RvZ2dsZVxuICAgICAqIEBtZW1iZXJvZiBUb29sdGlwXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ0b2dnbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgICAgaWYgKHRoaXMuX2lzT3Blbikge1xuICAgICAgICByZXR1cm4gdGhpcy5oaWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG93KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldENsYXNzZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q2xhc3NlcyhjbGFzc2VzKSB7XG4gICAgICB0aGlzLl9jbGFzc2VzID0gY2xhc3NlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy50aXRsZSA9IGNvbnRlbnQ7XG5cbiAgICAgIGlmICh0aGlzLl90b29sdGlwTm9kZSkge1xuICAgICAgICB0aGlzLl9zZXRDb250ZW50KGNvbnRlbnQsIHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgY2xhc3Nlc1VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBjbGFzc2VzID0gb3B0aW9ucyAmJiBvcHRpb25zLmNsYXNzZXMgfHwgZGlyZWN0aXZlLm9wdGlvbnMuZGVmYXVsdENsYXNzO1xuXG4gICAgICBpZiAoIWlzRXF1YWwodGhpcy5fY2xhc3NlcywgY2xhc3NlcykpIHtcbiAgICAgICAgdGhpcy5zZXRDbGFzc2VzKGNsYXNzZXMpO1xuICAgICAgICBjbGFzc2VzVXBkYXRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSBnZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgdmFyIG5lZWRQb3BwZXJVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHZhciBuZWVkUmVzdGFydCA9IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAhPT0gb3B0aW9ucy5vZmZzZXQgfHwgdGhpcy5vcHRpb25zLnBsYWNlbWVudCAhPT0gb3B0aW9ucy5wbGFjZW1lbnQpIHtcbiAgICAgICAgbmVlZFBvcHBlclVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGVtcGxhdGUgIT09IG9wdGlvbnMudGVtcGxhdGUgfHwgdGhpcy5vcHRpb25zLnRyaWdnZXIgIT09IG9wdGlvbnMudHJpZ2dlciB8fCB0aGlzLm9wdGlvbnMuY29udGFpbmVyICE9PSBvcHRpb25zLmNvbnRhaW5lciB8fCBjbGFzc2VzVXBkYXRlZCkge1xuICAgICAgICBuZWVkUmVzdGFydCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fdG9vbHRpcE5vZGUpIHtcbiAgICAgICAgaWYgKG5lZWRSZXN0YXJ0KSB7XG4gICAgICAgICAgdmFyIGlzT3BlbiA9IHRoaXMuX2lzT3BlbjtcbiAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcblxuICAgICAgICAgIHRoaXMuX2luaXQoKTtcblxuICAgICAgICAgIGlmIChpc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChuZWVkUG9wcGVyVXBkYXRlKSB7XG4gICAgICAgICAgdGhpcy5wb3BwZXJJbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy9cbiAgICAvLyBQcml2YXRlIG1ldGhvZHNcbiAgICAvL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgICAvLyBnZXQgZXZlbnRzIGxpc3RcbiAgICAgIHZhciBldmVudHMgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnRyaWdnZXIgPT09ICdzdHJpbmcnID8gdGhpcy5vcHRpb25zLnRyaWdnZXIuc3BsaXQoJyAnKSA6IFtdO1xuICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fZW5hYmxlRG9jdW1lbnRUb3VjaCA9IGV2ZW50cy5pbmRleE9mKCdtYW51YWwnKSA9PT0gLTE7XG4gICAgICBldmVudHMgPSBldmVudHMuZmlsdGVyKGZ1bmN0aW9uICh0cmlnZ2VyKSB7XG4gICAgICAgIHJldHVybiBbJ2NsaWNrJywgJ2hvdmVyJywgJ2ZvY3VzJ10uaW5kZXhPZih0cmlnZ2VyKSAhPT0gLTE7XG4gICAgICB9KTsgLy8gc2V0IGV2ZW50IGxpc3RlbmVyc1xuXG4gICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgZXZlbnRzLCB0aGlzLm9wdGlvbnMpOyAvLyB0aXRsZSBhdHRyaWJ1dGVcblxuXG4gICAgICB0aGlzLiRfb3JpZ2luYWxUaXRsZSA9IHRoaXMucmVmZXJlbmNlLmdldEF0dHJpYnV0ZSgndGl0bGUnKTtcbiAgICAgIHRoaXMucmVmZXJlbmNlLnJlbW92ZUF0dHJpYnV0ZSgndGl0bGUnKTtcbiAgICAgIHRoaXMucmVmZXJlbmNlLnNldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScsIHRoaXMuJF9vcmlnaW5hbFRpdGxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0b29sdGlwIG5vZGVcbiAgICAgKiBAbWVtYmVyb2YgVG9vbHRpcFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR8VGl0bGVGdW5jdGlvbn0gdGl0bGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFsbG93SHRtbFxuICAgICAqIEByZXR1cm4ge0hUTUxlbGVtZW50fSB0b29sdGlwTm9kZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlKHJlZmVyZW5jZSwgdGVtcGxhdGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAvLyBjcmVhdGUgdG9vbHRpcCBlbGVtZW50XG4gICAgICB2YXIgdG9vbHRpcEdlbmVyYXRvciA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRvb2x0aXBHZW5lcmF0b3IuaW5uZXJIVE1MID0gdGVtcGxhdGUudHJpbSgpO1xuICAgICAgdmFyIHRvb2x0aXBOb2RlID0gdG9vbHRpcEdlbmVyYXRvci5jaGlsZE5vZGVzWzBdOyAvLyBhZGQgdW5pcXVlIElEIHRvIG91ciB0b29sdGlwIChuZWVkZWQgZm9yIGFjY2Vzc2liaWxpdHkgcmVhc29ucylcblxuICAgICAgdG9vbHRpcE5vZGUuaWQgPSB0aGlzLm9wdGlvbnMuYXJpYUlkIHx8IFwidG9vbHRpcF9cIi5jb25jYXQoTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDEwKSk7IC8vIEluaXRpYWxseSBoaWRlIHRoZSB0b29sdGlwXG4gICAgICAvLyBUaGUgYXR0cmlidXRlIHdpbGwgYmUgc3dpdGNoZWQgaW4gYSBuZXh0IGZyYW1lIHNvXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMgY2FuIHBsYXlcblxuICAgICAgdG9vbHRpcE5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0hpZGUgJiYgdGhpcy5vcHRpb25zLnRyaWdnZXIuaW5kZXhPZignaG92ZXInKSAhPT0gLTEpIHtcbiAgICAgICAgdG9vbHRpcE5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLl9zY2hlZHVsZUhpZGUocmVmZXJlbmNlLCBfdGhpczIub3B0aW9ucy5kZWxheSwgX3RoaXMyLm9wdGlvbnMsIGV2dCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0b29sdGlwTm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLl9zY2hlZHVsZUhpZGUocmVmZXJlbmNlLCBfdGhpczIub3B0aW9ucy5kZWxheSwgX3RoaXMyLm9wdGlvbnMsIGV2dCk7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyByZXR1cm4gdGhlIGdlbmVyYXRlZCB0b29sdGlwIG5vZGVcblxuXG4gICAgICByZXR1cm4gdG9vbHRpcE5vZGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRDb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRDb250ZW50KGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB0aGlzLmFzeW5jQ29udGVudCA9IGZhbHNlO1xuXG4gICAgICB0aGlzLl9hcHBseUNvbnRlbnQoY29udGVudCwgb3B0aW9ucykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghX3RoaXMzLnBvcHBlckluc3RhbmNlKSByZXR1cm47XG5cbiAgICAgICAgX3RoaXMzLnBvcHBlckluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9hcHBseUNvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGx5Q29udGVudCh0aXRsZSwgb3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBhbGxvd0h0bWwgPSBvcHRpb25zLmh0bWw7XG4gICAgICAgIHZhciByb290Tm9kZSA9IF90aGlzNC5fdG9vbHRpcE5vZGU7XG4gICAgICAgIGlmICghcm9vdE5vZGUpIHJldHVybjtcbiAgICAgICAgdmFyIHRpdGxlTm9kZSA9IHJvb3ROb2RlLnF1ZXJ5U2VsZWN0b3IoX3RoaXM0Lm9wdGlvbnMuaW5uZXJTZWxlY3Rvcik7XG5cbiAgICAgICAgaWYgKHRpdGxlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgLy8gaWYgdGl0bGUgaXMgYSBub2RlLCBhcHBlbmQgaXQgb25seSBpZiBhbGxvd0h0bWwgaXMgdHJ1ZVxuICAgICAgICAgIGlmIChhbGxvd0h0bWwpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aXRsZU5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICB0aXRsZU5vZGUucmVtb3ZlQ2hpbGQodGl0bGVOb2RlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aXRsZU5vZGUuYXBwZW5kQ2hpbGQodGl0bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBpZiB0aXRsZSBpcyBhIGZ1bmN0aW9uLCBjYWxsIGl0IGFuZCBzZXQgaW5uZXJUZXh0IG9yIGlubmVySHRtbCBkZXBlbmRpbmcgYnkgYGFsbG93SHRtbGAgdmFsdWVcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdGl0bGUoKTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBfdGhpczQuYXN5bmNDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIG9wdGlvbnMubG9hZGluZ0NsYXNzICYmIGFkZENsYXNzZXMocm9vdE5vZGUsIG9wdGlvbnMubG9hZGluZ0NsYXNzKTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9hZGluZ0NvbnRlbnQpIHtcbiAgICAgICAgICAgICAgX3RoaXM0Ll9hcHBseUNvbnRlbnQob3B0aW9ucy5sb2FkaW5nQ29udGVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uIChhc3luY1Jlc3VsdCkge1xuICAgICAgICAgICAgICBvcHRpb25zLmxvYWRpbmdDbGFzcyAmJiByZW1vdmVDbGFzc2VzKHJvb3ROb2RlLCBvcHRpb25zLmxvYWRpbmdDbGFzcyk7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczQuX2FwcGx5Q29udGVudChhc3luY1Jlc3VsdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9KS50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzNC5fYXBwbHlDb250ZW50KHJlc3VsdCwgb3B0aW9ucykudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiBpdCdzIGp1c3QgYSBzaW1wbGUgdGV4dCwgc2V0IGlubmVyVGV4dCBvciBpbm5lckh0bWwgZGVwZW5kaW5nIGJ5IGBhbGxvd0h0bWxgIHZhbHVlXG4gICAgICAgICAgYWxsb3dIdG1sID8gdGl0bGVOb2RlLmlubmVySFRNTCA9IHRpdGxlIDogdGl0bGVOb2RlLmlubmVyVGV4dCA9IHRpdGxlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zaG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG93KHJlZmVyZW5jZSwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuY29udGFpbmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihvcHRpb25zLmNvbnRhaW5lcik7XG4gICAgICAgIGlmICghY29udGFpbmVyKSByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9kaXNwb3NlVGltZXIpO1xuICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgZGVsZXRlIG9wdGlvbnMub2Zmc2V0O1xuICAgICAgdmFyIHVwZGF0ZUNsYXNzZXMgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5fdG9vbHRpcE5vZGUpIHtcbiAgICAgICAgYWRkQ2xhc3Nlcyh0aGlzLl90b29sdGlwTm9kZSwgdGhpcy5fY2xhc3Nlcyk7XG4gICAgICAgIHVwZGF0ZUNsYXNzZXMgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2Vuc3VyZVNob3duKHJlZmVyZW5jZSwgb3B0aW9ucyk7XG5cbiAgICAgIGlmICh1cGRhdGVDbGFzc2VzICYmIHRoaXMuX3Rvb2x0aXBOb2RlKSB7XG4gICAgICAgIGFkZENsYXNzZXModGhpcy5fdG9vbHRpcE5vZGUsIHRoaXMuX2NsYXNzZXMpO1xuICAgICAgfVxuXG4gICAgICBhZGRDbGFzc2VzKHJlZmVyZW5jZSwgWyd2LXRvb2x0aXAtb3BlbiddKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9lbnN1cmVTaG93blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW5zdXJlU2hvd24ocmVmZXJlbmNlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgLy8gZG9uJ3Qgc2hvdyBpZiBpdCdzIGFscmVhZHkgdmlzaWJsZVxuICAgICAgaWYgKHRoaXMuX2lzT3Blbikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNPcGVuID0gdHJ1ZTtcbiAgICAgIG9wZW5Ub29sdGlwcy5wdXNoKHRoaXMpOyAvLyBpZiB0aGUgdG9vbHRpcE5vZGUgYWxyZWFkeSBleGlzdHMsIGp1c3Qgc2hvdyBpdFxuXG4gICAgICBpZiAodGhpcy5fdG9vbHRpcE5vZGUpIHtcbiAgICAgICAgdGhpcy5fdG9vbHRpcE5vZGUuc3R5bGUuZGlzcGxheSA9ICcnO1xuXG4gICAgICAgIHRoaXMuX3Rvb2x0aXBOb2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcblxuICAgICAgICB0aGlzLnBvcHBlckluc3RhbmNlLmVuYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMucG9wcGVySW5zdGFuY2UudXBkYXRlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuYXN5bmNDb250ZW50KSB7XG4gICAgICAgICAgdGhpcy5fc2V0Q29udGVudChvcHRpb25zLnRpdGxlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSAvLyBnZXQgdGl0bGVcblxuXG4gICAgICB2YXIgdGl0bGUgPSByZWZlcmVuY2UuZ2V0QXR0cmlidXRlKCd0aXRsZScpIHx8IG9wdGlvbnMudGl0bGU7IC8vIGRvbid0IHNob3cgdG9vbHRpcCBpZiBubyB0aXRsZSBpcyBkZWZpbmVkXG5cbiAgICAgIGlmICghdGl0bGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IC8vIGNyZWF0ZSB0b29sdGlwIG5vZGVcblxuXG4gICAgICB2YXIgdG9vbHRpcE5vZGUgPSB0aGlzLl9jcmVhdGUocmVmZXJlbmNlLCBvcHRpb25zLnRlbXBsYXRlKTtcblxuICAgICAgdGhpcy5fdG9vbHRpcE5vZGUgPSB0b29sdGlwTm9kZTsgLy8gQWRkIGBhcmlhLWRlc2NyaWJlZGJ5YCB0byBvdXIgcmVmZXJlbmNlIGVsZW1lbnQgZm9yIGFjY2Vzc2liaWxpdHkgcmVhc29uc1xuXG4gICAgICByZWZlcmVuY2Uuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JywgdG9vbHRpcE5vZGUuaWQpOyAvLyBhcHBlbmQgdG9vbHRpcCB0byBjb250YWluZXJcblxuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2ZpbmRDb250YWluZXIob3B0aW9ucy5jb250YWluZXIsIHJlZmVyZW5jZSk7XG5cbiAgICAgIHRoaXMuX2FwcGVuZCh0b29sdGlwTm9kZSwgY29udGFpbmVyKTtcblxuICAgICAgdmFyIHBvcHBlck9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkJDIoX29iamVjdFNwcmVhZCQyKHt9LCBvcHRpb25zLnBvcHBlck9wdGlvbnMpLCB7fSwge1xuICAgICAgICBwbGFjZW1lbnQ6IG9wdGlvbnMucGxhY2VtZW50XG4gICAgICB9KTtcblxuICAgICAgcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMgPSBfb2JqZWN0U3ByZWFkJDIoX29iamVjdFNwcmVhZCQyKHt9LCBwb3BwZXJPcHRpb25zLm1vZGlmaWVycyksIHt9LCB7XG4gICAgICAgIGFycm93OiB7XG4gICAgICAgICAgZWxlbWVudDogdGhpcy5vcHRpb25zLmFycm93U2VsZWN0b3JcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50KSB7XG4gICAgICAgIHBvcHBlck9wdGlvbnMubW9kaWZpZXJzLnByZXZlbnRPdmVyZmxvdyA9IHtcbiAgICAgICAgICBib3VuZGFyaWVzRWxlbWVudDogb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBvcHBlckluc3RhbmNlID0gbmV3IFBvcHBlcihyZWZlcmVuY2UsIHRvb2x0aXBOb2RlLCBwb3BwZXJPcHRpb25zKTtcblxuICAgICAgdGhpcy5fc2V0Q29udGVudCh0aXRsZSwgb3B0aW9ucyk7IC8vIEZpeCBwb3NpdGlvblxuXG5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghX3RoaXM1Ll9pc0Rpc3Bvc2VkICYmIF90aGlzNS5wb3BwZXJJbnN0YW5jZSkge1xuICAgICAgICAgIF90aGlzNS5wb3BwZXJJbnN0YW5jZS51cGRhdGUoKTsgLy8gU2hvdyB0aGUgdG9vbHRpcFxuXG5cbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpczUuX2lzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgX3RoaXM1Ll9pc09wZW4gJiYgdG9vbHRpcE5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXM1LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczUuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbm9Mb25nZXJPcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ub0xvbmdlck9wZW4oKSB7XG4gICAgICB2YXIgaW5kZXggPSBvcGVuVG9vbHRpcHMuaW5kZXhPZih0aGlzKTtcblxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBvcGVuVG9vbHRpcHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2hpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGUoKVxuICAgIC8qIHJlZmVyZW5jZSwgb3B0aW9ucyAqL1xuICAgIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICAvLyBkb24ndCBoaWRlIGlmIGl0J3MgYWxyZWFkeSBoaWRkZW5cbiAgICAgIGlmICghdGhpcy5faXNPcGVuKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc09wZW4gPSBmYWxzZTtcblxuICAgICAgdGhpcy5fbm9Mb25nZXJPcGVuKCk7IC8vIGhpZGUgdG9vbHRpcE5vZGVcblxuXG4gICAgICB0aGlzLl90b29sdGlwTm9kZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICB0aGlzLl90b29sdGlwTm9kZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgaWYgKHRoaXMucG9wcGVySW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5wb3BwZXJJbnN0YW5jZS5kaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIH1cblxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Rpc3Bvc2VUaW1lcik7XG4gICAgICB2YXIgZGlzcG9zZVRpbWUgPSBkaXJlY3RpdmUub3B0aW9ucy5kaXNwb3NlVGltZW91dDtcblxuICAgICAgaWYgKGRpc3Bvc2VUaW1lICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpczYuX3Rvb2x0aXBOb2RlKSB7XG4gICAgICAgICAgICBfdGhpczYuX3Rvb2x0aXBOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBfdGhpczYuaGlkZSk7XG5cbiAgICAgICAgICAgIF90aGlzNi5fdG9vbHRpcE5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBfdGhpczYuaGlkZSk7IC8vIERvbid0IHJlbW92ZSBwb3BwZXIgaW5zdGFuY2UsIGp1c3QgdGhlIEhUTUwgZWxlbWVudFxuXG5cbiAgICAgICAgICAgIF90aGlzNi5fcmVtb3ZlVG9vbHRpcE5vZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGRpc3Bvc2VUaW1lKTtcbiAgICAgIH1cblxuICAgICAgcmVtb3ZlQ2xhc3Nlcyh0aGlzLnJlZmVyZW5jZSwgWyd2LXRvb2x0aXAtb3BlbiddKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVtb3ZlVG9vbHRpcE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZVRvb2x0aXBOb2RlKCkge1xuICAgICAgaWYgKCF0aGlzLl90b29sdGlwTm9kZSkgcmV0dXJuO1xuICAgICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLl90b29sdGlwTm9kZS5wYXJlbnROb2RlO1xuXG4gICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX3Rvb2x0aXBOb2RlKTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2UucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5Jyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Rvb2x0aXBOb2RlID0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2Rpc3Bvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rpc3Bvc2UoKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICB0aGlzLnJlZmVyZW5jZS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnKTtcblxuICAgICAgaWYgKHRoaXMuJF9vcmlnaW5hbFRpdGxlKSB7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlLnNldEF0dHJpYnV0ZSgndGl0bGUnLCB0aGlzLiRfb3JpZ2luYWxUaXRsZSk7XG4gICAgICB9IC8vIHJlbW92ZSBldmVudCBsaXN0ZW5lcnMgZmlyc3QgdG8gcHJldmVudCBhbnkgdW5leHBlY3RlZCBiZWhhdmlvdXJcblxuXG4gICAgICB0aGlzLl9ldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgZnVuYyA9IF9yZWYuZnVuYyxcbiAgICAgICAgICAgIGV2ZW50ID0gX3JlZi5ldmVudDtcblxuICAgICAgICBfdGhpczcucmVmZXJlbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmMpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5fdG9vbHRpcE5vZGUpIHtcbiAgICAgICAgdGhpcy5faGlkZSgpO1xuXG4gICAgICAgIHRoaXMuX3Rvb2x0aXBOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCB0aGlzLmhpZGUpO1xuXG4gICAgICAgIHRoaXMuX3Rvb2x0aXBOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oaWRlKTsgLy8gZGVzdHJveSBpbnN0YW5jZVxuXG5cbiAgICAgICAgdGhpcy5wb3BwZXJJbnN0YW5jZS5kZXN0cm95KCk7IC8vIGRlc3Ryb3kgdG9vbHRpcE5vZGUgaWYgcmVtb3ZlT25EZXN0cm95IGlzIG5vdCBzZXQsIGFzIHBvcHBlckluc3RhbmNlLmRlc3Ryb3koKSBhbHJlYWR5IHJlbW92ZXMgdGhlIGVsZW1lbnRcblxuICAgICAgICBpZiAoIXRoaXMucG9wcGVySW5zdGFuY2Uub3B0aW9ucy5yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICAgICAgICB0aGlzLl9yZW1vdmVUb29sdGlwTm9kZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ub0xvbmdlck9wZW4oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9maW5kQ29udGFpbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQ29udGFpbmVyKGNvbnRhaW5lciwgcmVmZXJlbmNlKSB7XG4gICAgICAvLyBpZiBjb250YWluZXIgaXMgYSBxdWVyeSwgZ2V0IHRoZSByZWxhdGl2ZSBlbGVtZW50XG4gICAgICBpZiAodHlwZW9mIGNvbnRhaW5lciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29udGFpbmVyID0gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSBpZiAoY29udGFpbmVyID09PSBmYWxzZSkge1xuICAgICAgICAvLyBpZiBjb250YWluZXIgaXMgYGZhbHNlYCwgc2V0IGl0IHRvIHJlZmVyZW5jZSBwYXJlbnRcbiAgICAgICAgY29udGFpbmVyID0gcmVmZXJlbmNlLnBhcmVudE5vZGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGVuZCB0b29sdGlwIHRvIGNvbnRhaW5lclxuICAgICAqIEBtZW1iZXJvZiBUb29sdGlwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0b29sdGlwXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxTdHJpbmd8ZmFsc2V9IGNvbnRhaW5lclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FwcGVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwZW5kKHRvb2x0aXBOb2RlLCBjb250YWluZXIpIHtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0b29sdGlwTm9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0RXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBldmVudHMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICB2YXIgZGlyZWN0RXZlbnRzID0gW107XG4gICAgICB2YXIgb3Bwb3NpdGVFdmVudHMgPSBbXTtcbiAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50KSB7XG4gICAgICAgICAgY2FzZSAnaG92ZXInOlxuICAgICAgICAgICAgZGlyZWN0RXZlbnRzLnB1c2goJ21vdXNlZW50ZXInKTtcbiAgICAgICAgICAgIG9wcG9zaXRlRXZlbnRzLnB1c2goJ21vdXNlbGVhdmUnKTtcbiAgICAgICAgICAgIGlmIChfdGhpczgub3B0aW9ucy5oaWRlT25UYXJnZXRDbGljaykgb3Bwb3NpdGVFdmVudHMucHVzaCgnY2xpY2snKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZm9jdXMnOlxuICAgICAgICAgICAgZGlyZWN0RXZlbnRzLnB1c2goJ2ZvY3VzJyk7XG4gICAgICAgICAgICBvcHBvc2l0ZUV2ZW50cy5wdXNoKCdibHVyJyk7XG4gICAgICAgICAgICBpZiAoX3RoaXM4Lm9wdGlvbnMuaGlkZU9uVGFyZ2V0Q2xpY2spIG9wcG9zaXRlRXZlbnRzLnB1c2goJ2NsaWNrJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgICAgICAgIGRpcmVjdEV2ZW50cy5wdXNoKCdjbGljaycpO1xuICAgICAgICAgICAgb3Bwb3NpdGVFdmVudHMucHVzaCgnY2xpY2snKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gc2NoZWR1bGUgc2hvdyB0b29sdGlwXG5cbiAgICAgIGRpcmVjdEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgZnVuYyA9IGZ1bmN0aW9uIGZ1bmMoZXZ0KSB7XG4gICAgICAgICAgaWYgKF90aGlzOC5faXNPcGVuID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXZ0LnVzZWRCeVRvb2x0aXAgPSB0cnVlO1xuXG4gICAgICAgICAgX3RoaXM4Ll9zY2hlZHVsZVNob3cocmVmZXJlbmNlLCBvcHRpb25zLmRlbGF5LCBvcHRpb25zLCBldnQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzOC5fZXZlbnRzLnB1c2goe1xuICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICBmdW5jOiBmdW5jXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlZmVyZW5jZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmdW5jKTtcbiAgICAgIH0pOyAvLyBzY2hlZHVsZSBoaWRlIHRvb2x0aXBcblxuICAgICAgb3Bwb3NpdGVFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKGV2dCkge1xuICAgICAgICAgIGlmIChldnQudXNlZEJ5VG9vbHRpcCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzOC5fc2NoZWR1bGVIaWRlKHJlZmVyZW5jZSwgb3B0aW9ucy5kZWxheSwgb3B0aW9ucywgZXZ0KTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpczguX2V2ZW50cy5wdXNoKHtcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgZnVuYzogZnVuY1xuICAgICAgICB9KTtcblxuICAgICAgICByZWZlcmVuY2UuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uRG9jdW1lbnRUb3VjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Eb2N1bWVudFRvdWNoKGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5fZW5hYmxlRG9jdW1lbnRUb3VjaCkge1xuICAgICAgICB0aGlzLl9zY2hlZHVsZUhpZGUodGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5kZWxheSwgdGhpcy5vcHRpb25zLCBldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zY2hlZHVsZVNob3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NjaGVkdWxlU2hvdyhyZWZlcmVuY2UsIGRlbGF5LCBvcHRpb25zXG4gICAgLyosIGV2dCAqL1xuICAgICkge1xuICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICAgIC8vIGRlZmF1bHRzIHRvIDBcbiAgICAgIHZhciBjb21wdXRlZERlbGF5ID0gZGVsYXkgJiYgZGVsYXkuc2hvdyB8fCBkZWxheSB8fCAwO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3NjaGVkdWxlVGltZXIpO1xuICAgICAgdGhpcy5fc2NoZWR1bGVUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzOS5fc2hvdyhyZWZlcmVuY2UsIG9wdGlvbnMpO1xuICAgICAgfSwgY29tcHV0ZWREZWxheSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zY2hlZHVsZUhpZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NjaGVkdWxlSGlkZShyZWZlcmVuY2UsIGRlbGF5LCBvcHRpb25zLCBldnQpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcblxuICAgICAgLy8gZGVmYXVsdHMgdG8gMFxuICAgICAgdmFyIGNvbXB1dGVkRGVsYXkgPSBkZWxheSAmJiBkZWxheS5oaWRlIHx8IGRlbGF5IHx8IDA7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fc2NoZWR1bGVUaW1lcik7XG4gICAgICB0aGlzLl9zY2hlZHVsZVRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMxMC5faXNPcGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghX3RoaXMxMC5fdG9vbHRpcE5vZGUub3duZXJEb2N1bWVudC5ib2R5LmNvbnRhaW5zKF90aGlzMTAuX3Rvb2x0aXBOb2RlKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBpZiB3ZSBhcmUgaGlkaW5nIGJlY2F1c2Ugb2YgYSBtb3VzZWxlYXZlLCB3ZSBtdXN0IGNoZWNrIHRoYXQgdGhlIG5ld1xuICAgICAgICAvLyByZWZlcmVuY2UgaXNuJ3QgdGhlIHRvb2x0aXAsIGJlY2F1c2UgaW4gdGhpcyBjYXNlIHdlIGRvbid0IHdhbnQgdG8gaGlkZSBpdFxuXG5cbiAgICAgICAgaWYgKGV2dC50eXBlID09PSAnbW91c2VsZWF2ZScpIHtcbiAgICAgICAgICB2YXIgaXNTZXQgPSBfdGhpczEwLl9zZXRUb29sdGlwTm9kZUV2ZW50KGV2dCwgcmVmZXJlbmNlLCBkZWxheSwgb3B0aW9ucyk7IC8vIGlmIHdlIHNldCB0aGUgbmV3IGV2ZW50LCBkb24ndCBoaWRlIHRoZSB0b29sdGlwIHlldFxuICAgICAgICAgIC8vIHRoZSBuZXcgZXZlbnQgd2lsbCB0YWtlIGNhcmUgdG8gaGlkZSBpdCBpZiBuZWNlc3NhcnlcblxuXG4gICAgICAgICAgaWYgKGlzU2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMxMC5faGlkZShyZWZlcmVuY2UsIG9wdGlvbnMpO1xuICAgICAgfSwgY29tcHV0ZWREZWxheSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRvb2x0aXA7XG59KCk7IC8vIEhpZGUgdG9vbHRpcHMgb24gdG91Y2ggZGV2aWNlc1xuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcGVuVG9vbHRpcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9wZW5Ub29sdGlwc1tpXS5fb25Eb2N1bWVudFRvdWNoKGV2ZW50KTtcbiAgICB9XG4gIH0sIHN1cHBvcnRzUGFzc2l2ZSA/IHtcbiAgICBwYXNzaXZlOiB0cnVlLFxuICAgIGNhcHR1cmU6IHRydWVcbiAgfSA6IHRydWUpO1xufVxuLyoqXG4gKiBQbGFjZW1lbnQgZnVuY3Rpb24sIGl0cyBjb250ZXh0IGlzIHRoZSBUb29sdGlwIGluc3RhbmNlLlxuICogQG1lbWJlcm9mIFRvb2x0aXBcbiAqIEBjYWxsYmFjayBQbGFjZW1lbnRGdW5jdGlvblxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9vbHRpcCAtIHRvb2x0aXAgRE9NIG5vZGUuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2UgLSByZWZlcmVuY2UgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHBsYWNlbWVudCAtIE9uZSBvZiB0aGUgYWxsb3dlZCBwbGFjZW1lbnQgb3B0aW9ucy5cbiAqL1xuXG4vKipcbiAqIFRpdGxlIGZ1bmN0aW9uLCBpdHMgY29udGV4dCBpcyB0aGUgVG9vbHRpcCBpbnN0YW5jZS5cbiAqIEBtZW1iZXJvZiBUb29sdGlwXG4gKiBAY2FsbGJhY2sgVGl0bGVGdW5jdGlvblxuICogQHJldHVybiB7U3RyaW5nfSBwbGFjZW1lbnQgLSBUaGUgZGVzaXJlZCB0aXRsZS5cbiAqL1xuXG5mdW5jdGlvbiBvd25LZXlzJDEob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIHN0YXRlID0ge1xuICBlbmFibGVkOiB0cnVlXG59O1xudmFyIHBvc2l0aW9ucyA9IFsndG9wJywgJ3RvcC1zdGFydCcsICd0b3AtZW5kJywgJ3JpZ2h0JywgJ3JpZ2h0LXN0YXJ0JywgJ3JpZ2h0LWVuZCcsICdib3R0b20nLCAnYm90dG9tLXN0YXJ0JywgJ2JvdHRvbS1lbmQnLCAnbGVmdCcsICdsZWZ0LXN0YXJ0JywgJ2xlZnQtZW5kJ107XG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIC8vIERlZmF1bHQgdG9vbHRpcCBwbGFjZW1lbnQgcmVsYXRpdmUgdG8gdGFyZ2V0IGVsZW1lbnRcbiAgZGVmYXVsdFBsYWNlbWVudDogJ3RvcCcsXG4gIC8vIERlZmF1bHQgQ1NTIGNsYXNzZXMgYXBwbGllZCB0byB0aGUgdG9vbHRpcCBlbGVtZW50XG4gIGRlZmF1bHRDbGFzczogJ3Z1ZS10b29sdGlwLXRoZW1lJyxcbiAgLy8gRGVmYXVsdCBDU1MgY2xhc3NlcyBhcHBsaWVkIHRvIHRoZSB0YXJnZXQgZWxlbWVudCBvZiB0aGUgdG9vbHRpcFxuICBkZWZhdWx0VGFyZ2V0Q2xhc3M6ICdoYXMtdG9vbHRpcCcsXG4gIC8vIElzIHRoZSBjb250ZW50IEhUTUwgYnkgZGVmYXVsdD9cbiAgZGVmYXVsdEh0bWw6IHRydWUsXG4gIC8vIERlZmF1bHQgSFRNTCB0ZW1wbGF0ZSBvZiB0aGUgdG9vbHRpcCBlbGVtZW50XG4gIC8vIEl0IG11c3QgaW5jbHVkZSBgdG9vbHRpcC1hcnJvd2AgJiBgdG9vbHRpcC1pbm5lcmAgQ1NTIGNsYXNzZXMgKGNhbiBiZSBjb25maWd1cmVkLCBzZWUgYmVsb3cpXG4gIC8vIENoYW5nZSBpZiB0aGUgY2xhc3NlcyBjb25mbGljdCB3aXRoIG90aGVyIGxpYnJhcmllcyAoZm9yIGV4YW1wbGUgYm9vdHN0cmFwKVxuICBkZWZhdWx0VGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwidG9vbHRpcFwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBjbGFzcz1cInRvb2x0aXAtYXJyb3dcIj48L2Rpdj48ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiPjwvZGl2PjwvZGl2PicsXG4gIC8vIFNlbGVjdG9yIHVzZWQgdG8gZ2V0IHRoZSBhcnJvdyBlbGVtZW50IGluIHRoZSB0b29sdGlwIHRlbXBsYXRlXG4gIGRlZmF1bHRBcnJvd1NlbGVjdG9yOiAnLnRvb2x0aXAtYXJyb3csIC50b29sdGlwX19hcnJvdycsXG4gIC8vIFNlbGVjdG9yIHVzZWQgdG8gZ2V0IHRoZSBpbm5lciBjb250ZW50IGVsZW1lbnQgaW4gdGhlIHRvb2x0aXAgdGVtcGxhdGVcbiAgZGVmYXVsdElubmVyU2VsZWN0b3I6ICcudG9vbHRpcC1pbm5lciwgLnRvb2x0aXBfX2lubmVyJyxcbiAgLy8gRGVsYXkgKG1zKVxuICBkZWZhdWx0RGVsYXk6IDAsXG4gIC8vIERlZmF1bHQgZXZlbnRzIHRoYXQgdHJpZ2dlciB0aGUgdG9vbHRpcFxuICBkZWZhdWx0VHJpZ2dlcjogJ2hvdmVyIGZvY3VzJyxcbiAgLy8gRGVmYXVsdCBwb3NpdGlvbiBvZmZzZXQgKHB4KVxuICBkZWZhdWx0T2Zmc2V0OiAwLFxuICAvLyBEZWZhdWx0IGNvbnRhaW5lciB3aGVyZSB0aGUgdG9vbHRpcCB3aWxsIGJlIGFwcGVuZGVkXG4gIGRlZmF1bHRDb250YWluZXI6ICdib2R5JyxcbiAgZGVmYXVsdEJvdW5kYXJpZXNFbGVtZW50OiB1bmRlZmluZWQsXG4gIGRlZmF1bHRQb3BwZXJPcHRpb25zOiB7fSxcbiAgLy8gQ2xhc3MgYWRkZWQgd2hlbiBjb250ZW50IGlzIGxvYWRpbmdcbiAgZGVmYXVsdExvYWRpbmdDbGFzczogJ3Rvb2x0aXAtbG9hZGluZycsXG4gIC8vIERpc3BsYXllZCB3aGVuIHRvb2x0aXAgY29udGVudCBpcyBsb2FkaW5nXG4gIGRlZmF1bHRMb2FkaW5nQ29udGVudDogJy4uLicsXG4gIC8vIEhpZGUgb24gbW91c2VvdmVyIHRvb2x0aXBcbiAgYXV0b0hpZGU6IHRydWUsXG4gIC8vIENsb3NlIHRvb2x0aXAgb24gY2xpY2sgb24gdG9vbHRpcCB0YXJnZXQ/XG4gIGRlZmF1bHRIaWRlT25UYXJnZXRDbGljazogdHJ1ZSxcbiAgLy8gQXV0byBkZXN0cm95IHRvb2x0aXAgRE9NIG5vZGVzIChtcylcbiAgZGlzcG9zZVRpbWVvdXQ6IDUwMDAsXG4gIC8vIE9wdGlvbnMgZm9yIHBvcG92ZXJcbiAgcG9wb3Zlcjoge1xuICAgIGRlZmF1bHRQbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgIC8vIFVzZSB0aGUgYHBvcG92ZXJDbGFzc2AgcHJvcCBmb3IgdGhlbWluZ1xuICAgIGRlZmF1bHRDbGFzczogJ3Z1ZS1wb3BvdmVyLXRoZW1lJyxcbiAgICAvLyBCYXNlIGNsYXNzIChjaGFuZ2UgaWYgY29uZmxpY3RzIHdpdGggb3RoZXIgbGlicmFyaWVzKVxuICAgIGRlZmF1bHRCYXNlQ2xhc3M6ICd0b29sdGlwIHBvcG92ZXInLFxuICAgIC8vIFdyYXBwZXIgY2xhc3MgKGNvbnRhaW5zIGFycm93IGFuZCBpbm5lcilcbiAgICBkZWZhdWx0V3JhcHBlckNsYXNzOiAnd3JhcHBlcicsXG4gICAgLy8gSW5uZXIgY29udGVudCBjbGFzc1xuICAgIGRlZmF1bHRJbm5lckNsYXNzOiAndG9vbHRpcC1pbm5lciBwb3BvdmVyLWlubmVyJyxcbiAgICAvLyBBcnJvdyBjbGFzc1xuICAgIGRlZmF1bHRBcnJvd0NsYXNzOiAndG9vbHRpcC1hcnJvdyBwb3BvdmVyLWFycm93JyxcbiAgICAvLyBDbGFzcyBhZGRlZCB3aGVuIHBvcG92ZXIgaXMgb3BlblxuICAgIGRlZmF1bHRPcGVuQ2xhc3M6ICdvcGVuJyxcbiAgICBkZWZhdWx0RGVsYXk6IDAsXG4gICAgZGVmYXVsdFRyaWdnZXI6ICdjbGljaycsXG4gICAgZGVmYXVsdE9mZnNldDogMCxcbiAgICBkZWZhdWx0Q29udGFpbmVyOiAnYm9keScsXG4gICAgZGVmYXVsdEJvdW5kYXJpZXNFbGVtZW50OiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFBvcHBlck9wdGlvbnM6IHt9LFxuICAgIC8vIEhpZGVzIGlmIGNsaWNrZWQgb3V0c2lkZSBvZiBwb3BvdmVyXG4gICAgZGVmYXVsdEF1dG9IaWRlOiB0cnVlLFxuICAgIC8vIFVwZGF0ZSBwb3BwZXIgb24gY29udGVudCByZXNpemVcbiAgICBkZWZhdWx0SGFuZGxlUmVzaXplOiB0cnVlXG4gIH1cbn07XG5mdW5jdGlvbiBnZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBwbGFjZW1lbnQ6IHR5cGVvZiBvcHRpb25zLnBsYWNlbWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnBsYWNlbWVudCA6IGRpcmVjdGl2ZS5vcHRpb25zLmRlZmF1bHRQbGFjZW1lbnQsXG4gICAgZGVsYXk6IHR5cGVvZiBvcHRpb25zLmRlbGF5ICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuZGVsYXkgOiBkaXJlY3RpdmUub3B0aW9ucy5kZWZhdWx0RGVsYXksXG4gICAgaHRtbDogdHlwZW9mIG9wdGlvbnMuaHRtbCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmh0bWwgOiBkaXJlY3RpdmUub3B0aW9ucy5kZWZhdWx0SHRtbCxcbiAgICB0ZW1wbGF0ZTogdHlwZW9mIG9wdGlvbnMudGVtcGxhdGUgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy50ZW1wbGF0ZSA6IGRpcmVjdGl2ZS5vcHRpb25zLmRlZmF1bHRUZW1wbGF0ZSxcbiAgICBhcnJvd1NlbGVjdG9yOiB0eXBlb2Ygb3B0aW9ucy5hcnJvd1NlbGVjdG9yICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuYXJyb3dTZWxlY3RvciA6IGRpcmVjdGl2ZS5vcHRpb25zLmRlZmF1bHRBcnJvd1NlbGVjdG9yLFxuICAgIGlubmVyU2VsZWN0b3I6IHR5cGVvZiBvcHRpb25zLmlubmVyU2VsZWN0b3IgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5pbm5lclNlbGVjdG9yIDogZGlyZWN0aXZlLm9wdGlvbnMuZGVmYXVsdElubmVyU2VsZWN0b3IsXG4gICAgdHJpZ2dlcjogdHlwZW9mIG9wdGlvbnMudHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnRyaWdnZXIgOiBkaXJlY3RpdmUub3B0aW9ucy5kZWZhdWx0VHJpZ2dlcixcbiAgICBvZmZzZXQ6IHR5cGVvZiBvcHRpb25zLm9mZnNldCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm9mZnNldCA6IGRpcmVjdGl2ZS5vcHRpb25zLmRlZmF1bHRPZmZzZXQsXG4gICAgY29udGFpbmVyOiB0eXBlb2Ygb3B0aW9ucy5jb250YWluZXIgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5jb250YWluZXIgOiBkaXJlY3RpdmUub3B0aW9ucy5kZWZhdWx0Q29udGFpbmVyLFxuICAgIGJvdW5kYXJpZXNFbGVtZW50OiB0eXBlb2Ygb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50IDogZGlyZWN0aXZlLm9wdGlvbnMuZGVmYXVsdEJvdW5kYXJpZXNFbGVtZW50LFxuICAgIGF1dG9IaWRlOiB0eXBlb2Ygb3B0aW9ucy5hdXRvSGlkZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmF1dG9IaWRlIDogZGlyZWN0aXZlLm9wdGlvbnMuYXV0b0hpZGUsXG4gICAgaGlkZU9uVGFyZ2V0Q2xpY2s6IHR5cGVvZiBvcHRpb25zLmhpZGVPblRhcmdldENsaWNrICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuaGlkZU9uVGFyZ2V0Q2xpY2sgOiBkaXJlY3RpdmUub3B0aW9ucy5kZWZhdWx0SGlkZU9uVGFyZ2V0Q2xpY2ssXG4gICAgbG9hZGluZ0NsYXNzOiB0eXBlb2Ygb3B0aW9ucy5sb2FkaW5nQ2xhc3MgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5sb2FkaW5nQ2xhc3MgOiBkaXJlY3RpdmUub3B0aW9ucy5kZWZhdWx0TG9hZGluZ0NsYXNzLFxuICAgIGxvYWRpbmdDb250ZW50OiB0eXBlb2Ygb3B0aW9ucy5sb2FkaW5nQ29udGVudCAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmxvYWRpbmdDb250ZW50IDogZGlyZWN0aXZlLm9wdGlvbnMuZGVmYXVsdExvYWRpbmdDb250ZW50LFxuICAgIHBvcHBlck9wdGlvbnM6IF9vYmplY3RTcHJlYWQkMSh7fSwgdHlwZW9mIG9wdGlvbnMucG9wcGVyT3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnBvcHBlck9wdGlvbnMgOiBkaXJlY3RpdmUub3B0aW9ucy5kZWZhdWx0UG9wcGVyT3B0aW9ucylcbiAgfTtcblxuICBpZiAocmVzdWx0Lm9mZnNldCkge1xuICAgIHZhciB0eXBlb2ZPZmZzZXQgPSBfdHlwZW9mKHJlc3VsdC5vZmZzZXQpO1xuXG4gICAgdmFyIG9mZnNldCA9IHJlc3VsdC5vZmZzZXQ7IC8vIE9uZSB2YWx1ZSAtPiBzd2l0Y2hcblxuICAgIGlmICh0eXBlb2ZPZmZzZXQgPT09ICdudW1iZXInIHx8IHR5cGVvZk9mZnNldCA9PT0gJ3N0cmluZycgJiYgb2Zmc2V0LmluZGV4T2YoJywnKSA9PT0gLTEpIHtcbiAgICAgIG9mZnNldCA9IFwiMCwgXCIuY29uY2F0KG9mZnNldCk7XG4gICAgfVxuXG4gICAgaWYgKCFyZXN1bHQucG9wcGVyT3B0aW9ucy5tb2RpZmllcnMpIHtcbiAgICAgIHJlc3VsdC5wb3BwZXJPcHRpb25zLm1vZGlmaWVycyA9IHt9O1xuICAgIH1cblxuICAgIHJlc3VsdC5wb3BwZXJPcHRpb25zLm1vZGlmaWVycy5vZmZzZXQgPSB7XG4gICAgICBvZmZzZXQ6IG9mZnNldFxuICAgIH07XG4gIH1cblxuICBpZiAocmVzdWx0LnRyaWdnZXIgJiYgcmVzdWx0LnRyaWdnZXIuaW5kZXhPZignY2xpY2snKSAhPT0gLTEpIHtcbiAgICByZXN1bHQuaGlkZU9uVGFyZ2V0Q2xpY2sgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRQbGFjZW1lbnQodmFsdWUsIG1vZGlmaWVycykge1xuICB2YXIgcGxhY2VtZW50ID0gdmFsdWUucGxhY2VtZW50O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBvcyA9IHBvc2l0aW9uc1tpXTtcblxuICAgIGlmIChtb2RpZmllcnNbcG9zXSkge1xuICAgICAgcGxhY2VtZW50ID0gcG9zO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwbGFjZW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRDb250ZW50KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gX3R5cGVvZih2YWx1ZSk7XG5cbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwKGVsLCB2YWx1ZSkge1xuICB2YXIgbW9kaWZpZXJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgdmFyIGNvbnRlbnQgPSBnZXRDb250ZW50KHZhbHVlKTtcbiAgdmFyIGNsYXNzZXMgPSB0eXBlb2YgdmFsdWUuY2xhc3NlcyAhPT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZS5jbGFzc2VzIDogZGlyZWN0aXZlLm9wdGlvbnMuZGVmYXVsdENsYXNzO1xuXG4gIHZhciBvcHRzID0gX29iamVjdFNwcmVhZCQxKHtcbiAgICB0aXRsZTogY29udGVudFxuICB9LCBnZXRPcHRpb25zKF9vYmplY3RTcHJlYWQkMShfb2JqZWN0U3ByZWFkJDEoe30sIF90eXBlb2YodmFsdWUpID09PSAnb2JqZWN0JyA/IHZhbHVlIDoge30pLCB7fSwge1xuICAgIHBsYWNlbWVudDogZ2V0UGxhY2VtZW50KHZhbHVlLCBtb2RpZmllcnMpXG4gIH0pKSk7XG5cbiAgdmFyIHRvb2x0aXAgPSBlbC5fdG9vbHRpcCA9IG5ldyBUb29sdGlwKGVsLCBvcHRzKTtcbiAgdG9vbHRpcC5zZXRDbGFzc2VzKGNsYXNzZXMpO1xuICB0b29sdGlwLl92dWVFbCA9IGVsOyAvLyBDbGFzcyBvbiB0YXJnZXRcblxuICB2YXIgdGFyZ2V0Q2xhc3NlcyA9IHR5cGVvZiB2YWx1ZS50YXJnZXRDbGFzc2VzICE9PSAndW5kZWZpbmVkJyA/IHZhbHVlLnRhcmdldENsYXNzZXMgOiBkaXJlY3RpdmUub3B0aW9ucy5kZWZhdWx0VGFyZ2V0Q2xhc3M7XG4gIGVsLl90b29sdGlwVGFyZ2V0Q2xhc3NlcyA9IHRhcmdldENsYXNzZXM7XG4gIGFkZENsYXNzZXMoZWwsIHRhcmdldENsYXNzZXMpO1xuICByZXR1cm4gdG9vbHRpcDtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lUb29sdGlwKGVsKSB7XG4gIGlmIChlbC5fdG9vbHRpcCkge1xuICAgIGVsLl90b29sdGlwLmRpc3Bvc2UoKTtcblxuICAgIGRlbGV0ZSBlbC5fdG9vbHRpcDtcbiAgICBkZWxldGUgZWwuX3Rvb2x0aXBPbGRTaG93O1xuICB9XG5cbiAgaWYgKGVsLl90b29sdGlwVGFyZ2V0Q2xhc3Nlcykge1xuICAgIHJlbW92ZUNsYXNzZXMoZWwsIGVsLl90b29sdGlwVGFyZ2V0Q2xhc3Nlcyk7XG4gICAgZGVsZXRlIGVsLl90b29sdGlwVGFyZ2V0Q2xhc3NlcztcbiAgfVxufVxuZnVuY3Rpb24gYmluZChlbCwgX3JlZikge1xuICB2YXIgdmFsdWUgPSBfcmVmLnZhbHVlO1xuICAgICAgX3JlZi5vbGRWYWx1ZTtcbiAgICAgIHZhciBtb2RpZmllcnMgPSBfcmVmLm1vZGlmaWVycztcbiAgdmFyIGNvbnRlbnQgPSBnZXRDb250ZW50KHZhbHVlKTtcblxuICBpZiAoIWNvbnRlbnQgfHwgIXN0YXRlLmVuYWJsZWQpIHtcbiAgICBkZXN0cm95VG9vbHRpcChlbCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRvb2x0aXA7XG5cbiAgICBpZiAoZWwuX3Rvb2x0aXApIHtcbiAgICAgIHRvb2x0aXAgPSBlbC5fdG9vbHRpcDsgLy8gQ29udGVudFxuXG4gICAgICB0b29sdGlwLnNldENvbnRlbnQoY29udGVudCk7IC8vIE9wdGlvbnNcblxuICAgICAgdG9vbHRpcC5zZXRPcHRpb25zKF9vYmplY3RTcHJlYWQkMShfb2JqZWN0U3ByZWFkJDEoe30sIHZhbHVlKSwge30sIHtcbiAgICAgICAgcGxhY2VtZW50OiBnZXRQbGFjZW1lbnQodmFsdWUsIG1vZGlmaWVycylcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9vbHRpcCA9IGNyZWF0ZVRvb2x0aXAoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIH0gLy8gTWFudWFsIHNob3dcblxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZS5zaG93ICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZS5zaG93ICE9PSBlbC5fdG9vbHRpcE9sZFNob3cpIHtcbiAgICAgIGVsLl90b29sdGlwT2xkU2hvdyA9IHZhbHVlLnNob3c7XG4gICAgICB2YWx1ZS5zaG93ID8gdG9vbHRpcC5zaG93KCkgOiB0b29sdGlwLmhpZGUoKTtcbiAgICB9XG4gIH1cbn1cbnZhciBkaXJlY3RpdmUgPSB7XG4gIG9wdGlvbnM6IGRlZmF1bHRPcHRpb25zLFxuICBiaW5kOiBiaW5kLFxuICB1cGRhdGU6IGJpbmQsXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kKGVsKSB7XG4gICAgZGVzdHJveVRvb2x0aXAoZWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcnMoZWwpIHtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkNsaWNrKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgc3VwcG9ydHNQYXNzaXZlID8ge1xuICAgIHBhc3NpdmU6IHRydWVcbiAgfSA6IGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKGVsKSB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGljayk7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQpO1xuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hFbmQpO1xuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIG9uVG91Y2hDYW5jZWwpO1xufVxuXG5mdW5jdGlvbiBvbkNsaWNrKGV2ZW50KSB7XG4gIHZhciBlbCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gIGV2ZW50LmNsb3NlUG9wb3ZlciA9ICFlbC4kX3ZjbG9zZXBvcG92ZXJfdG91Y2g7XG4gIGV2ZW50LmNsb3NlQWxsUG9wb3ZlciA9IGVsLiRfY2xvc2VQb3BvdmVyTW9kaWZpZXJzICYmICEhZWwuJF9jbG9zZVBvcG92ZXJNb2RpZmllcnMuYWxsO1xufVxuXG5mdW5jdGlvbiBvblRvdWNoU3RhcnQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBlbCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgZWwuJF92Y2xvc2Vwb3BvdmVyX3RvdWNoID0gdHJ1ZTtcbiAgICB2YXIgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICBlbC4kX3ZjbG9zZXBvcG92ZXJfdG91Y2hQb2ludCA9IHRvdWNoO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCBvblRvdWNoQ2FuY2VsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvblRvdWNoRW5kKGV2ZW50KSB7XG4gIHZhciBlbCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gIGVsLiRfdmNsb3NlcG9wb3Zlcl90b3VjaCA9IGZhbHNlO1xuXG4gIGlmIChldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICB2YXIgZmlyc3RUb3VjaCA9IGVsLiRfdmNsb3NlcG9wb3Zlcl90b3VjaFBvaW50O1xuICAgIGV2ZW50LmNsb3NlUG9wb3ZlciA9IE1hdGguYWJzKHRvdWNoLnNjcmVlblkgLSBmaXJzdFRvdWNoLnNjcmVlblkpIDwgMjAgJiYgTWF0aC5hYnModG91Y2guc2NyZWVuWCAtIGZpcnN0VG91Y2guc2NyZWVuWCkgPCAyMDtcbiAgICBldmVudC5jbG9zZUFsbFBvcG92ZXIgPSBlbC4kX2Nsb3NlUG9wb3Zlck1vZGlmaWVycyAmJiAhIWVsLiRfY2xvc2VQb3BvdmVyTW9kaWZpZXJzLmFsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBvblRvdWNoQ2FuY2VsKGV2ZW50KSB7XG4gIHZhciBlbCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gIGVsLiRfdmNsb3NlcG9wb3Zlcl90b3VjaCA9IGZhbHNlO1xufVxuXG52YXIgdmNsb3NlcG9wb3ZlciA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZChlbCwgX3JlZikge1xuICAgIHZhciB2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgICAgIG1vZGlmaWVycyA9IF9yZWYubW9kaWZpZXJzO1xuICAgIGVsLiRfY2xvc2VQb3BvdmVyTW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUpIHtcbiAgICAgIGFkZExpc3RlbmVycyhlbCk7XG4gICAgfVxuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShlbCwgX3JlZjIpIHtcbiAgICB2YXIgdmFsdWUgPSBfcmVmMi52YWx1ZSxcbiAgICAgICAgb2xkVmFsdWUgPSBfcmVmMi5vbGRWYWx1ZSxcbiAgICAgICAgbW9kaWZpZXJzID0gX3JlZjIubW9kaWZpZXJzO1xuICAgIGVsLiRfY2xvc2VQb3BvdmVyTW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuXG4gICAgaWYgKHZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUpIHtcbiAgICAgICAgYWRkTGlzdGVuZXJzKGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVycyhlbCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZChlbCkge1xuICAgIHJlbW92ZUxpc3RlbmVycyhlbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0KGtleSkge1xuICB2YXIgdmFsdWUgPSBkaXJlY3RpdmUub3B0aW9ucy5wb3BvdmVyW2tleV07XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZGlyZWN0aXZlLm9wdGlvbnNba2V5XTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIGlzSU9TID0gZmFsc2U7XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICBpc0lPUyA9IC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF3aW5kb3cuTVNTdHJlYW07XG59XG5cbnZhciBvcGVuUG9wb3ZlcnMgPSBbXTtcblxudmFyIEVsZW1lbnQgPSBmdW5jdGlvbiBFbGVtZW50KCkge307XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBFbGVtZW50ID0gd2luZG93LkVsZW1lbnQ7XG59XG5cbnZhciBzY3JpcHQgPSB7XG4gIG5hbWU6ICdWUG9wb3ZlcicsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBSZXNpemVPYnNlcnZlcjogUmVzaXplT2JzZXJ2ZXJcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBvcGVuOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGRpc2FibGVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHBsYWNlbWVudDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBnZXREZWZhdWx0KCdkZWZhdWx0UGxhY2VtZW50Jyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZWxheToge1xuICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyLCBPYmplY3RdLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBnZXREZWZhdWx0KCdkZWZhdWx0RGVsYXknKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9mZnNldDoge1xuICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gZ2V0RGVmYXVsdCgnZGVmYXVsdE9mZnNldCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdHJpZ2dlcjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBnZXREZWZhdWx0KCdkZWZhdWx0VHJpZ2dlcicpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29udGFpbmVyOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBPYmplY3QsIEVsZW1lbnQsIEJvb2xlYW5dLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBnZXREZWZhdWx0KCdkZWZhdWx0Q29udGFpbmVyJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBib3VuZGFyaWVzRWxlbWVudDoge1xuICAgICAgdHlwZTogW1N0cmluZywgRWxlbWVudF0sXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldERlZmF1bHQoJ2RlZmF1bHRCb3VuZGFyaWVzRWxlbWVudCcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcG9wcGVyT3B0aW9uczoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBnZXREZWZhdWx0KCdkZWZhdWx0UG9wcGVyT3B0aW9ucycpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcG9wb3ZlckNsYXNzOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheV0sXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldERlZmF1bHQoJ2RlZmF1bHRDbGFzcycpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcG9wb3ZlckJhc2VDbGFzczoge1xuICAgICAgdHlwZTogW1N0cmluZywgQXJyYXldLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBkaXJlY3RpdmUub3B0aW9ucy5wb3BvdmVyLmRlZmF1bHRCYXNlQ2xhc3M7XG4gICAgICB9XG4gICAgfSxcbiAgICBwb3BvdmVySW5uZXJDbGFzczoge1xuICAgICAgdHlwZTogW1N0cmluZywgQXJyYXldLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBkaXJlY3RpdmUub3B0aW9ucy5wb3BvdmVyLmRlZmF1bHRJbm5lckNsYXNzO1xuICAgICAgfVxuICAgIH0sXG4gICAgcG9wb3ZlcldyYXBwZXJDbGFzczoge1xuICAgICAgdHlwZTogW1N0cmluZywgQXJyYXldLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBkaXJlY3RpdmUub3B0aW9ucy5wb3BvdmVyLmRlZmF1bHRXcmFwcGVyQ2xhc3M7XG4gICAgICB9XG4gICAgfSxcbiAgICBwb3BvdmVyQXJyb3dDbGFzczoge1xuICAgICAgdHlwZTogW1N0cmluZywgQXJyYXldLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBkaXJlY3RpdmUub3B0aW9ucy5wb3BvdmVyLmRlZmF1bHRBcnJvd0NsYXNzO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXV0b0hpZGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIGRpcmVjdGl2ZS5vcHRpb25zLnBvcG92ZXIuZGVmYXVsdEF1dG9IaWRlO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFuZGxlUmVzaXplOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBkaXJlY3RpdmUub3B0aW9ucy5wb3BvdmVyLmRlZmF1bHRIYW5kbGVSZXNpemU7XG4gICAgICB9XG4gICAgfSxcbiAgICBvcGVuR3JvdXA6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIG9wZW5DbGFzczoge1xuICAgICAgdHlwZTogW1N0cmluZywgQXJyYXldLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBkaXJlY3RpdmUub3B0aW9ucy5wb3BvdmVyLmRlZmF1bHRPcGVuQ2xhc3M7XG4gICAgICB9XG4gICAgfSxcbiAgICBhcmlhSWQ6IHtcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzT3BlbjogZmFsc2UsXG4gICAgICBpZDogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDEwKVxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgY3NzQ2xhc3M6IGZ1bmN0aW9uIGNzc0NsYXNzKCkge1xuICAgICAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eSh7fSwgdGhpcy5vcGVuQ2xhc3MsIHRoaXMuaXNPcGVuKTtcbiAgICB9LFxuICAgIHBvcG92ZXJJZDogZnVuY3Rpb24gcG9wb3ZlcklkKCkge1xuICAgICAgcmV0dXJuIFwicG9wb3Zlcl9cIi5jb25jYXQodGhpcy5hcmlhSWQgIT0gbnVsbCA/IHRoaXMuYXJpYUlkIDogdGhpcy5pZCk7XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIG9wZW46IGZ1bmN0aW9uIG9wZW4odmFsKSB7XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaXNhYmxlZDogZnVuY3Rpb24gZGlzYWJsZWQodmFsLCBvbGRWYWwpIHtcbiAgICAgIGlmICh2YWwgIT09IG9sZFZhbCkge1xuICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcGVuKSB7XG4gICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbnRhaW5lcjogZnVuY3Rpb24gY29udGFpbmVyKHZhbCkge1xuICAgICAgaWYgKHRoaXMuaXNPcGVuICYmIHRoaXMucG9wcGVySW5zdGFuY2UpIHtcbiAgICAgICAgdmFyIHBvcG92ZXJOb2RlID0gdGhpcy4kcmVmcy5wb3BvdmVyO1xuICAgICAgICB2YXIgcmVmZXJlbmNlID0gdGhpcy4kcmVmcy50cmlnZ2VyO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy4kX2ZpbmRDb250YWluZXIodGhpcy5jb250YWluZXIsIHJlZmVyZW5jZSk7XG5cbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ05vIGNvbnRhaW5lciBmb3IgcG9wb3ZlcicsIHRoaXMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChwb3BvdmVyTm9kZSk7XG4gICAgICAgIHRoaXMucG9wcGVySW5zdGFuY2Uuc2NoZWR1bGVVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIodmFsKSB7XG4gICAgICB0aGlzLiRfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuJF9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH0sXG4gICAgcGxhY2VtZW50OiBmdW5jdGlvbiBwbGFjZW1lbnQodmFsKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLiRfdXBkYXRlUG9wcGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucG9wcGVySW5zdGFuY2Uub3B0aW9ucy5wbGFjZW1lbnQgPSB2YWw7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG9mZnNldDogJyRfcmVzdGFydFBvcHBlcicsXG4gICAgYm91bmRhcmllc0VsZW1lbnQ6ICckX3Jlc3RhcnRQb3BwZXInLFxuICAgIHBvcHBlck9wdGlvbnM6IHtcbiAgICAgIGhhbmRsZXI6ICckX3Jlc3RhcnRQb3BwZXInLFxuICAgICAgZGVlcDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCgpIHtcbiAgICB0aGlzLiRfaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuJF9tb3VudGVkID0gZmFsc2U7XG4gICAgdGhpcy4kX2V2ZW50cyA9IFtdO1xuICAgIHRoaXMuJF9wcmV2ZW50T3BlbiA9IGZhbHNlO1xuICB9LFxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHZhciBwb3BvdmVyTm9kZSA9IHRoaXMuJHJlZnMucG9wb3ZlcjtcbiAgICBwb3BvdmVyTm9kZS5wYXJlbnROb2RlICYmIHBvcG92ZXJOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocG9wb3Zlck5vZGUpO1xuICAgIHRoaXMuJF9pbml0KCk7XG5cbiAgICBpZiAodGhpcy5vcGVuKSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH0sXG4gIGRlYWN0aXZhdGVkOiBmdW5jdGlvbiBkZWFjdGl2YXRlZCgpIHtcbiAgICB0aGlzLmhpZGUoKTtcbiAgfSxcbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHNob3c6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBldmVudCA9IF9yZWYyLmV2ZW50O1xuICAgICAgICAgIF9yZWYyLnNraXBEZWxheTtcbiAgICAgICAgICB2YXIgX3JlZjIkZm9yY2UgPSBfcmVmMi5mb3JjZSxcbiAgICAgICAgICBmb3JjZSA9IF9yZWYyJGZvcmNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyJGZvcmNlO1xuXG4gICAgICBpZiAoZm9yY2UgfHwgIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy4kX3NjaGVkdWxlU2hvdyhldmVudCk7XG4gICAgICAgIHRoaXMuJGVtaXQoJ3Nob3cnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4kZW1pdCgndXBkYXRlOm9wZW4nLCB0cnVlKTtcbiAgICAgIHRoaXMuJF9iZWluZ1Nob3dlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuJF9iZWluZ1Nob3dlZCA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgdmFyIF9yZWYzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBldmVudCA9IF9yZWYzLmV2ZW50O1xuICAgICAgICAgIF9yZWYzLnNraXBEZWxheTtcblxuICAgICAgdGhpcy4kX3NjaGVkdWxlSGlkZShldmVudCk7XG4gICAgICB0aGlzLiRlbWl0KCdoaWRlJyk7XG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6b3BlbicsIGZhbHNlKTtcbiAgICB9LFxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICB0aGlzLiRfaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICB0aGlzLiRfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuaGlkZSh7XG4gICAgICAgIHNraXBEZWxheTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMucG9wcGVySW5zdGFuY2UuZGVzdHJveSgpOyAvLyBkZXN0cm95IHRvb2x0aXBOb2RlIGlmIHJlbW92ZU9uRGVzdHJveSBpcyBub3Qgc2V0LCBhcyBwb3BwZXJJbnN0YW5jZS5kZXN0cm95KCkgYWxyZWFkeSByZW1vdmVzIHRoZSBlbGVtZW50XG5cbiAgICAgICAgaWYgKCF0aGlzLnBvcHBlckluc3RhbmNlLm9wdGlvbnMucmVtb3ZlT25EZXN0cm95KSB7XG4gICAgICAgICAgdmFyIHBvcG92ZXJOb2RlID0gdGhpcy4kcmVmcy5wb3BvdmVyO1xuICAgICAgICAgIHBvcG92ZXJOb2RlLnBhcmVudE5vZGUgJiYgcG9wb3Zlck5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwb3BvdmVyTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy4kX21vdW50ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucG9wcGVySW5zdGFuY2UgPSBudWxsO1xuICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuJGVtaXQoJ2Rpc3Bvc2UnKTtcbiAgICB9LFxuICAgICRfaW5pdDogZnVuY3Rpb24gJF9pbml0KCkge1xuICAgICAgaWYgKHRoaXMudHJpZ2dlci5pbmRleE9mKCdtYW51YWwnKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy4kX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAkX3Nob3c6IGZ1bmN0aW9uICRfc2hvdygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgcmVmZXJlbmNlID0gdGhpcy4kcmVmcy50cmlnZ2VyO1xuICAgICAgdmFyIHBvcG92ZXJOb2RlID0gdGhpcy4kcmVmcy5wb3BvdmVyO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuJF9kaXNwb3NlVGltZXIpOyAvLyBBbHJlYWR5IG9wZW5cblxuICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gUG9wcGVyIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWRcblxuXG4gICAgICBpZiAodGhpcy5wb3BwZXJJbnN0YW5jZSkge1xuICAgICAgICB0aGlzLmlzT3BlbiA9IHRydWU7XG4gICAgICAgIHRoaXMucG9wcGVySW5zdGFuY2UuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5wb3BwZXJJbnN0YW5jZS5zY2hlZHVsZVVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuJF9tb3VudGVkKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLiRfZmluZENvbnRhaW5lcih0aGlzLmNvbnRhaW5lciwgcmVmZXJlbmNlKTtcblxuICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignTm8gY29udGFpbmVyIGZvciBwb3BvdmVyJywgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHBvcG92ZXJOb2RlKTtcbiAgICAgICAgdGhpcy4kX21vdW50ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMzLmhpZGRlbikge1xuICAgICAgICAgICAgICBfdGhpczMuaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMucG9wcGVySW5zdGFuY2UpIHtcbiAgICAgICAgdmFyIHBvcHBlck9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMucG9wcGVyT3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgcGxhY2VtZW50OiB0aGlzLnBsYWNlbWVudFxuICAgICAgICB9KTtcblxuICAgICAgICBwb3BwZXJPcHRpb25zLm1vZGlmaWVycyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMpLCB7fSwge1xuICAgICAgICAgIGFycm93OiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBvcHBlck9wdGlvbnMubW9kaWZpZXJzICYmIHBvcHBlck9wdGlvbnMubW9kaWZpZXJzLmFycm93KSwge30sIHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuJHJlZnMuYXJyb3dcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5vZmZzZXQpIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy4kX2dldE9mZnNldCgpO1xuICAgICAgICAgIHBvcHBlck9wdGlvbnMubW9kaWZpZXJzLm9mZnNldCA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMgJiYgcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMub2Zmc2V0KSwge30sIHtcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ib3VuZGFyaWVzRWxlbWVudCkge1xuICAgICAgICAgIHBvcHBlck9wdGlvbnMubW9kaWZpZXJzLnByZXZlbnRPdmVyZmxvdyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMgJiYgcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMucHJldmVudE92ZXJmbG93KSwge30sIHtcbiAgICAgICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiB0aGlzLmJvdW5kYXJpZXNFbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBvcHBlckluc3RhbmNlID0gbmV3IFBvcHBlcihyZWZlcmVuY2UsIHBvcG92ZXJOb2RlLCBwb3BwZXJPcHRpb25zKTsgLy8gRml4IHBvc2l0aW9uXG5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMzLmhpZGRlbikge1xuICAgICAgICAgICAgX3RoaXMzLmhpZGRlbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICBfdGhpczMuJF9oaWRlKCk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIV90aGlzMy4kX2lzRGlzcG9zZWQgJiYgX3RoaXMzLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICAgICAgICBfdGhpczMucG9wcGVySW5zdGFuY2Uuc2NoZWR1bGVVcGRhdGUoKTsgLy8gU2hvdyB0aGUgdG9vbHRpcFxuXG5cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChfdGhpczMuaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMzLmhpZGRlbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgX3RoaXMzLiRfaGlkZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFfdGhpczMuJF9pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMzLmlzT3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzMy5kaXNwb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9wZW5Hcm91cCA9IHRoaXMub3Blbkdyb3VwO1xuXG4gICAgICBpZiAob3Blbkdyb3VwKSB7XG4gICAgICAgIHZhciBwb3BvdmVyO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3BlblBvcG92ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcG9wb3ZlciA9IG9wZW5Qb3BvdmVyc1tpXTtcblxuICAgICAgICAgIGlmIChwb3BvdmVyLm9wZW5Hcm91cCAhPT0gb3Blbkdyb3VwKSB7XG4gICAgICAgICAgICBwb3BvdmVyLmhpZGUoKTtcbiAgICAgICAgICAgIHBvcG92ZXIuJGVtaXQoJ2Nsb3NlLWdyb3VwJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9wZW5Qb3BvdmVycy5wdXNoKHRoaXMpO1xuICAgICAgdGhpcy4kZW1pdCgnYXBwbHktc2hvdycpO1xuICAgIH0sXG4gICAgJF9oaWRlOiBmdW5jdGlvbiAkX2hpZGUoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgLy8gQWxyZWFkeSBoaWRkZW5cbiAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXggPSBvcGVuUG9wb3ZlcnMuaW5kZXhPZih0aGlzKTtcblxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBvcGVuUG9wb3ZlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMucG9wcGVySW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5wb3BwZXJJbnN0YW5jZS5kaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIH1cblxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuJF9kaXNwb3NlVGltZXIpO1xuICAgICAgdmFyIGRpc3Bvc2VUaW1lID0gZGlyZWN0aXZlLm9wdGlvbnMucG9wb3Zlci5kaXNwb3NlVGltZW91dCB8fCBkaXJlY3RpdmUub3B0aW9ucy5kaXNwb3NlVGltZW91dDtcblxuICAgICAgaWYgKGRpc3Bvc2VUaW1lICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuJF9kaXNwb3NlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcG9wb3Zlck5vZGUgPSBfdGhpczQuJHJlZnMucG9wb3ZlcjtcblxuICAgICAgICAgIGlmIChwb3BvdmVyTm9kZSkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgcmVtb3ZlIHBvcHBlciBpbnN0YW5jZSwganVzdCB0aGUgSFRNTCBlbGVtZW50XG4gICAgICAgICAgICBwb3BvdmVyTm9kZS5wYXJlbnROb2RlICYmIHBvcG92ZXJOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocG9wb3Zlck5vZGUpO1xuICAgICAgICAgICAgX3RoaXM0LiRfbW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgZGlzcG9zZVRpbWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRlbWl0KCdhcHBseS1oaWRlJyk7XG4gICAgfSxcbiAgICAkX2ZpbmRDb250YWluZXI6IGZ1bmN0aW9uICRfZmluZENvbnRhaW5lcihjb250YWluZXIsIHJlZmVyZW5jZSkge1xuICAgICAgLy8gaWYgY29udGFpbmVyIGlzIGEgcXVlcnksIGdldCB0aGUgcmVsYXRpdmUgZWxlbWVudFxuICAgICAgaWYgKHR5cGVvZiBjb250YWluZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnRhaW5lciA9IHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRhaW5lcik7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRhaW5lciA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gaWYgY29udGFpbmVyIGlzIGBmYWxzZWAsIHNldCBpdCB0byByZWZlcmVuY2UgcGFyZW50XG4gICAgICAgIGNvbnRhaW5lciA9IHJlZmVyZW5jZS5wYXJlbnROb2RlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH0sXG4gICAgJF9nZXRPZmZzZXQ6IGZ1bmN0aW9uICRfZ2V0T2Zmc2V0KCkge1xuICAgICAgdmFyIHR5cGVvZk9mZnNldCA9IF90eXBlb2YodGhpcy5vZmZzZXQpO1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7IC8vIE9uZSB2YWx1ZSAtPiBzd2l0Y2hcblxuICAgICAgaWYgKHR5cGVvZk9mZnNldCA9PT0gJ251bWJlcicgfHwgdHlwZW9mT2Zmc2V0ID09PSAnc3RyaW5nJyAmJiBvZmZzZXQuaW5kZXhPZignLCcpID09PSAtMSkge1xuICAgICAgICBvZmZzZXQgPSBcIjAsIFwiLmNvbmNhdChvZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH0sXG4gICAgJF9hZGRFdmVudExpc3RlbmVyczogZnVuY3Rpb24gJF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB2YXIgcmVmZXJlbmNlID0gdGhpcy4kcmVmcy50cmlnZ2VyO1xuICAgICAgdmFyIGRpcmVjdEV2ZW50cyA9IFtdO1xuICAgICAgdmFyIG9wcG9zaXRlRXZlbnRzID0gW107XG4gICAgICB2YXIgZXZlbnRzID0gdHlwZW9mIHRoaXMudHJpZ2dlciA9PT0gJ3N0cmluZycgPyB0aGlzLnRyaWdnZXIuc3BsaXQoJyAnKS5maWx0ZXIoZnVuY3Rpb24gKHRyaWdnZXIpIHtcbiAgICAgICAgcmV0dXJuIFsnY2xpY2snLCAnaG92ZXInLCAnZm9jdXMnXS5pbmRleE9mKHRyaWdnZXIpICE9PSAtMTtcbiAgICAgIH0pIDogW107XG4gICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudCkge1xuICAgICAgICAgIGNhc2UgJ2hvdmVyJzpcbiAgICAgICAgICAgIGRpcmVjdEV2ZW50cy5wdXNoKCdtb3VzZWVudGVyJyk7XG4gICAgICAgICAgICBvcHBvc2l0ZUV2ZW50cy5wdXNoKCdtb3VzZWxlYXZlJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2ZvY3VzJzpcbiAgICAgICAgICAgIGRpcmVjdEV2ZW50cy5wdXNoKCdmb2N1cycpO1xuICAgICAgICAgICAgb3Bwb3NpdGVFdmVudHMucHVzaCgnYmx1cicpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdjbGljayc6XG4gICAgICAgICAgICBkaXJlY3RFdmVudHMucHVzaCgnY2xpY2snKTtcbiAgICAgICAgICAgIG9wcG9zaXRlRXZlbnRzLnB1c2goJ2NsaWNrJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIHNjaGVkdWxlIHNob3cgdG9vbHRpcFxuXG4gICAgICBkaXJlY3RFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKF90aGlzNS5pc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBldmVudC51c2VkQnlUb29sdGlwID0gdHJ1ZTtcbiAgICAgICAgICAhX3RoaXM1LiRfcHJldmVudE9wZW4gJiYgX3RoaXM1LnNob3coe1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX3RoaXM1LmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzNS4kX2V2ZW50cy5wdXNoKHtcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgZnVuYzogZnVuY1xuICAgICAgICB9KTtcblxuICAgICAgICByZWZlcmVuY2UuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYyk7XG4gICAgICB9KTsgLy8gc2NoZWR1bGUgaGlkZSB0b29sdGlwXG5cbiAgICAgIG9wcG9zaXRlRXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBmdW5jID0gZnVuY3Rpb24gZnVuYyhldmVudCkge1xuICAgICAgICAgIGlmIChldmVudC51c2VkQnlUb29sdGlwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXM1LmhpZGUoe1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBfdGhpczUuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpczUuJF9ldmVudHMucHVzaCh7XG4gICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIGZ1bmM6IGZ1bmNcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmVmZXJlbmNlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmMpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAkX3NjaGVkdWxlU2hvdzogZnVuY3Rpb24gJF9zY2hlZHVsZVNob3coKSB7XG4gICAgICB2YXIgc2tpcERlbGF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiRfc2NoZWR1bGVUaW1lcik7XG5cbiAgICAgIGlmIChza2lwRGVsYXkpIHtcbiAgICAgICAgdGhpcy4kX3Nob3coKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHRzIHRvIDBcbiAgICAgICAgdmFyIGNvbXB1dGVkRGVsYXkgPSBwYXJzZUludCh0aGlzLmRlbGF5ICYmIHRoaXMuZGVsYXkuc2hvdyB8fCB0aGlzLmRlbGF5IHx8IDApO1xuICAgICAgICB0aGlzLiRfc2NoZWR1bGVUaW1lciA9IHNldFRpbWVvdXQodGhpcy4kX3Nob3cuYmluZCh0aGlzKSwgY29tcHV0ZWREZWxheSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAkX3NjaGVkdWxlSGlkZTogZnVuY3Rpb24gJF9zY2hlZHVsZUhpZGUoKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgdmFyIGV2ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgdmFyIHNraXBEZWxheSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4kX3NjaGVkdWxlVGltZXIpO1xuXG4gICAgICBpZiAoc2tpcERlbGF5KSB7XG4gICAgICAgIHRoaXMuJF9oaWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0cyB0byAwXG4gICAgICAgIHZhciBjb21wdXRlZERlbGF5ID0gcGFyc2VJbnQodGhpcy5kZWxheSAmJiB0aGlzLmRlbGF5LmhpZGUgfHwgdGhpcy5kZWxheSB8fCAwKTtcbiAgICAgICAgdGhpcy4kX3NjaGVkdWxlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIV90aGlzNi5pc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIGlmIHdlIGFyZSBoaWRpbmcgYmVjYXVzZSBvZiBhIG1vdXNlbGVhdmUsIHdlIG11c3QgY2hlY2sgdGhhdCB0aGUgbmV3XG4gICAgICAgICAgLy8gcmVmZXJlbmNlIGlzbid0IHRoZSB0b29sdGlwLCBiZWNhdXNlIGluIHRoaXMgY2FzZSB3ZSBkb24ndCB3YW50IHRvIGhpZGUgaXRcblxuXG4gICAgICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09ICdtb3VzZWxlYXZlJykge1xuICAgICAgICAgICAgdmFyIGlzU2V0ID0gX3RoaXM2LiRfc2V0VG9vbHRpcE5vZGVFdmVudChldmVudCk7IC8vIGlmIHdlIHNldCB0aGUgbmV3IGV2ZW50LCBkb24ndCBoaWRlIHRoZSB0b29sdGlwIHlldFxuICAgICAgICAgICAgLy8gdGhlIG5ldyBldmVudCB3aWxsIHRha2UgY2FyZSB0byBoaWRlIGl0IGlmIG5lY2Vzc2FyeVxuXG5cbiAgICAgICAgICAgIGlmIChpc1NldCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXM2LiRfaGlkZSgpO1xuICAgICAgICB9LCBjb21wdXRlZERlbGF5KTtcbiAgICAgIH1cbiAgICB9LFxuICAgICRfc2V0VG9vbHRpcE5vZGVFdmVudDogZnVuY3Rpb24gJF9zZXRUb29sdGlwTm9kZUV2ZW50KGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdmFyIHJlZmVyZW5jZSA9IHRoaXMuJHJlZnMudHJpZ2dlcjtcbiAgICAgIHZhciBwb3BvdmVyTm9kZSA9IHRoaXMuJHJlZnMucG9wb3ZlcjtcbiAgICAgIHZhciByZWxhdGVkcmVmZXJlbmNlID0gZXZlbnQucmVsYXRlZHJlZmVyZW5jZSB8fCBldmVudC50b0VsZW1lbnQgfHwgZXZlbnQucmVsYXRlZFRhcmdldDtcblxuICAgICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soZXZlbnQyKSB7XG4gICAgICAgIHZhciByZWxhdGVkcmVmZXJlbmNlMiA9IGV2ZW50Mi5yZWxhdGVkcmVmZXJlbmNlIHx8IGV2ZW50Mi50b0VsZW1lbnQgfHwgZXZlbnQyLnJlbGF0ZWRUYXJnZXQ7IC8vIFJlbW92ZSBldmVudCBsaXN0ZW5lciBhZnRlciBjYWxsXG5cbiAgICAgICAgcG9wb3Zlck5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudC50eXBlLCBjYWxsYmFjayk7IC8vIElmIHRoZSBuZXcgcmVmZXJlbmNlIGlzIG5vdCB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcblxuICAgICAgICBpZiAoIXJlZmVyZW5jZS5jb250YWlucyhyZWxhdGVkcmVmZXJlbmNlMikpIHtcbiAgICAgICAgICAvLyBTY2hlZHVsZSB0byBoaWRlIHRvb2x0aXBcbiAgICAgICAgICBfdGhpczcuaGlkZSh7XG4gICAgICAgICAgICBldmVudDogZXZlbnQyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChwb3BvdmVyTm9kZS5jb250YWlucyhyZWxhdGVkcmVmZXJlbmNlKSkge1xuICAgICAgICAvLyBsaXN0ZW4gdG8gbW91c2VsZWF2ZSBvbiB0aGUgdG9vbHRpcCBlbGVtZW50IHRvIGJlIGFibGUgdG8gaGlkZSB0aGUgdG9vbHRpcFxuICAgICAgICBwb3BvdmVyTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LnR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgICRfcmVtb3ZlRXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uICRfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgcmVmZXJlbmNlID0gdGhpcy4kcmVmcy50cmlnZ2VyO1xuICAgICAgdGhpcy4kX2V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgICAgICB2YXIgZnVuYyA9IF9yZWY0LmZ1bmMsXG4gICAgICAgICAgICBldmVudCA9IF9yZWY0LmV2ZW50O1xuICAgICAgICByZWZlcmVuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuJF9ldmVudHMgPSBbXTtcbiAgICB9LFxuICAgICRfdXBkYXRlUG9wcGVyOiBmdW5jdGlvbiAkX3VwZGF0ZVBvcHBlcihjYikge1xuICAgICAgaWYgKHRoaXMucG9wcGVySW5zdGFuY2UpIHtcbiAgICAgICAgY2IoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB0aGlzLnBvcHBlckluc3RhbmNlLnNjaGVkdWxlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAkX3Jlc3RhcnRQb3BwZXI6IGZ1bmN0aW9uICRfcmVzdGFydFBvcHBlcigpIHtcbiAgICAgIGlmICh0aGlzLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICAgIHZhciBpc09wZW4gPSB0aGlzLmlzT3BlbjtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuJF9pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJF9pbml0KCk7XG5cbiAgICAgICAgaWYgKGlzT3Blbikge1xuICAgICAgICAgIHRoaXMuc2hvdyh7XG4gICAgICAgICAgICBza2lwRGVsYXk6IHRydWUsXG4gICAgICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAkX2hhbmRsZUdsb2JhbENsb3NlOiBmdW5jdGlvbiAkX2hhbmRsZUdsb2JhbENsb3NlKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICAgICAgdmFyIHRvdWNoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIGlmICh0aGlzLiRfYmVpbmdTaG93ZWQpIHJldHVybjtcbiAgICAgIHRoaXMuaGlkZSh7XG4gICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChldmVudC5jbG9zZVBvcG92ZXIpIHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2xvc2UtZGlyZWN0aXZlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiRlbWl0KCdhdXRvLWhpZGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRvdWNoKSB7XG4gICAgICAgIHRoaXMuJF9wcmV2ZW50T3BlbiA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzOC4kX3ByZXZlbnRPcGVuID0gZmFsc2U7XG4gICAgICAgIH0sIDMwMCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAkX2hhbmRsZVJlc2l6ZTogZnVuY3Rpb24gJF9oYW5kbGVSZXNpemUoKSB7XG4gICAgICBpZiAodGhpcy5pc09wZW4gJiYgdGhpcy5wb3BwZXJJbnN0YW5jZSkge1xuICAgICAgICB0aGlzLnBvcHBlckluc3RhbmNlLnNjaGVkdWxlVXBkYXRlKCk7XG4gICAgICAgIHRoaXMuJGVtaXQoJ3Jlc2l6ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgaWYgKGlzSU9TKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBoYW5kbGVHbG9iYWxUb3VjaGVuZCwgc3VwcG9ydHNQYXNzaXZlID8ge1xuICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9IDogdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlR2xvYmFsQ2xpY2ssIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUdsb2JhbENsaWNrKGV2ZW50KSB7XG4gIGhhbmRsZUdsb2JhbENsb3NlKGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlR2xvYmFsVG91Y2hlbmQoZXZlbnQpIHtcbiAgaGFuZGxlR2xvYmFsQ2xvc2UoZXZlbnQsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVHbG9iYWxDbG9zZShldmVudCkge1xuICB2YXIgdG91Y2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICB2YXIgcG9wb3ZlciA9IG9wZW5Qb3BvdmVyc1tpXTtcblxuICAgIGlmIChwb3BvdmVyLiRyZWZzLnBvcG92ZXIpIHtcbiAgICAgIHZhciBjb250YWlucyA9IHBvcG92ZXIuJHJlZnMucG9wb3Zlci5jb250YWlucyhldmVudC50YXJnZXQpO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGV2ZW50LmNsb3NlQWxsUG9wb3ZlciB8fCBldmVudC5jbG9zZVBvcG92ZXIgJiYgY29udGFpbnMgfHwgcG9wb3Zlci5hdXRvSGlkZSAmJiAhY29udGFpbnMpIHtcbiAgICAgICAgICBwb3BvdmVyLiRfaGFuZGxlR2xvYmFsQ2xvc2UoZXZlbnQsIHRvdWNoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIERlbGF5IHNvIHRoYXQgY2xvc2UgZGlyZWN0aXZlIGhhcyB0aW1lIHRvIHNldCB2YWx1ZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcGVuUG9wb3ZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBfbG9vcChpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQodGVtcGxhdGUsIHN0eWxlLCBzY3JpcHQsIHNjb3BlSWQsIGlzRnVuY3Rpb25hbFRlbXBsYXRlLCBtb2R1bGVJZGVudGlmaWVyIC8qIHNlcnZlciBvbmx5ICovLCBzaGFkb3dNb2RlLCBjcmVhdGVJbmplY3RvciwgY3JlYXRlSW5qZWN0b3JTU1IsIGNyZWF0ZUluamVjdG9yU2hhZG93KSB7XHJcbiAgICBpZiAodHlwZW9mIHNoYWRvd01vZGUgIT09ICdib29sZWFuJykge1xyXG4gICAgICAgIGNyZWF0ZUluamVjdG9yU1NSID0gY3JlYXRlSW5qZWN0b3I7XHJcbiAgICAgICAgY3JlYXRlSW5qZWN0b3IgPSBzaGFkb3dNb2RlO1xyXG4gICAgICAgIHNoYWRvd01vZGUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3AuXHJcbiAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIHNjcmlwdCA9PT0gJ2Z1bmN0aW9uJyA/IHNjcmlwdC5vcHRpb25zIDogc2NyaXB0O1xyXG4gICAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xyXG4gICAgaWYgKHRlbXBsYXRlICYmIHRlbXBsYXRlLnJlbmRlcikge1xyXG4gICAgICAgIG9wdGlvbnMucmVuZGVyID0gdGVtcGxhdGUucmVuZGVyO1xyXG4gICAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gdGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xyXG4gICAgICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZTtcclxuICAgICAgICAvLyBmdW5jdGlvbmFsIHRlbXBsYXRlXHJcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25hbFRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gc2NvcGVkSWRcclxuICAgIGlmIChzY29wZUlkKSB7XHJcbiAgICAgICAgb3B0aW9ucy5fc2NvcGVJZCA9IHNjb3BlSWQ7XHJcbiAgICB9XHJcbiAgICBsZXQgaG9vaztcclxuICAgIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7XHJcbiAgICAgICAgLy8gc2VydmVyIGJ1aWxkXHJcbiAgICAgICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgIC8vIDIuMyBpbmplY3Rpb25cclxuICAgICAgICAgICAgY29udGV4dCA9XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCk7IC8vIGZ1bmN0aW9uYWxcclxuICAgICAgICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXHJcbiAgICAgICAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXHJcbiAgICAgICAgICAgIGlmIChzdHlsZSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuY2FsbCh0aGlzLCBjcmVhdGVJbmplY3RvclNTUihjb250ZXh0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcmVuY2VcclxuICAgICAgICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcclxuICAgICAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxyXG4gICAgICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9vaztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHN0eWxlKSB7XHJcbiAgICAgICAgaG9vayA9IHNoYWRvd01vZGVcclxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuY2FsbCh0aGlzLCBjcmVhdGVJbmplY3RvclNoYWRvdyhjb250ZXh0LCB0aGlzLiRyb290LiRvcHRpb25zLnNoYWRvd1Jvb3QpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5jYWxsKHRoaXMsIGNyZWF0ZUluamVjdG9yKGNvbnRleHQpKTtcclxuICAgICAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGlmIChob29rKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZnVuY3Rpb25hbCkge1xyXG4gICAgICAgICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlcjtcclxuICAgICAgICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24oaCwgY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCByZWdpc3RyYXRpb24gYXMgYmVmb3JlQ3JlYXRlIGhvb2tcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZTtcclxuICAgICAgICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaykgOiBbaG9va107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNjcmlwdDtcclxufVxuXG4vKiBzY3JpcHQgKi9cbnZhciBfX3Z1ZV9zY3JpcHRfXyA9IHNjcmlwdDtcbi8qIHRlbXBsYXRlICovXG5cbnZhciBfX3Z1ZV9yZW5kZXJfXyA9IGZ1bmN0aW9uIF9fdnVlX3JlbmRlcl9fKCkge1xuICB2YXIgX3ZtID0gdGhpcztcblxuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnQ7XG5cbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oO1xuXG4gIHJldHVybiBfYyhcImRpdlwiLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwidi1wb3BvdmVyXCIsXG4gICAgY2xhc3M6IF92bS5jc3NDbGFzc1xuICB9LCBbX2MoXCJkaXZcIiwge1xuICAgIHJlZjogXCJ0cmlnZ2VyXCIsXG4gICAgc3RhdGljQ2xhc3M6IFwidHJpZ2dlclwiLFxuICAgIHN0YXRpY1N0eWxlOiB7XG4gICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiXG4gICAgfSxcbiAgICBhdHRyczoge1xuICAgICAgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IF92bS5pc09wZW4gPyBfdm0ucG9wb3ZlcklkIDogdW5kZWZpbmVkLFxuICAgICAgdGFiaW5kZXg6IF92bS50cmlnZ2VyLmluZGV4T2YoXCJmb2N1c1wiKSAhPT0gLTEgPyAwIDogdW5kZWZpbmVkXG4gICAgfVxuICB9LCBbX3ZtLl90KFwiZGVmYXVsdFwiKV0sIDIpLCBfdm0uX3YoXCIgXCIpLCBfYyhcImRpdlwiLCB7XG4gICAgcmVmOiBcInBvcG92ZXJcIixcbiAgICBjbGFzczogW192bS5wb3BvdmVyQmFzZUNsYXNzLCBfdm0ucG9wb3ZlckNsYXNzLCBfdm0uY3NzQ2xhc3NdLFxuICAgIHN0eWxlOiB7XG4gICAgICB2aXNpYmlsaXR5OiBfdm0uaXNPcGVuID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiXG4gICAgfSxcbiAgICBhdHRyczoge1xuICAgICAgaWQ6IF92bS5wb3BvdmVySWQsXG4gICAgICBcImFyaWEtaGlkZGVuXCI6IF92bS5pc09wZW4gPyBcImZhbHNlXCIgOiBcInRydWVcIixcbiAgICAgIHRhYmluZGV4OiBfdm0uYXV0b0hpZGUgPyAwIDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICBvbjoge1xuICAgICAga2V5dXA6IGZ1bmN0aW9uIGtleXVwKCRldmVudCkge1xuICAgICAgICBpZiAoISRldmVudC50eXBlLmluZGV4T2YoXCJrZXlcIikgJiYgX3ZtLl9rKCRldmVudC5rZXlDb2RlLCBcImVzY1wiLCAyNywgJGV2ZW50LmtleSwgW1wiRXNjXCIsIFwiRXNjYXBlXCJdKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgX3ZtLmF1dG9IaWRlICYmIF92bS5oaWRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbX2MoXCJkaXZcIiwge1xuICAgIGNsYXNzOiBfdm0ucG9wb3ZlcldyYXBwZXJDbGFzc1xuICB9LCBbX2MoXCJkaXZcIiwge1xuICAgIHJlZjogXCJpbm5lclwiLFxuICAgIGNsYXNzOiBfdm0ucG9wb3ZlcklubmVyQ2xhc3MsXG4gICAgc3RhdGljU3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCJcbiAgICB9XG4gIH0sIFtfYyhcImRpdlwiLCBbX3ZtLl90KFwicG9wb3ZlclwiLCBudWxsLCB7XG4gICAgaXNPcGVuOiBfdm0uaXNPcGVuXG4gIH0pXSwgMiksIF92bS5fdihcIiBcIiksIF92bS5oYW5kbGVSZXNpemUgPyBfYyhcIlJlc2l6ZU9ic2VydmVyXCIsIHtcbiAgICBvbjoge1xuICAgICAgbm90aWZ5OiBfdm0uJF9oYW5kbGVSZXNpemVcbiAgICB9XG4gIH0pIDogX3ZtLl9lKCldLCAxKSwgX3ZtLl92KFwiIFwiKSwgX2MoXCJkaXZcIiwge1xuICAgIHJlZjogXCJhcnJvd1wiLFxuICAgIGNsYXNzOiBfdm0ucG9wb3ZlckFycm93Q2xhc3NcbiAgfSldKV0pXSk7XG59O1xuXG52YXIgX192dWVfc3RhdGljUmVuZGVyRm5zX18gPSBbXTtcbl9fdnVlX3JlbmRlcl9fLl93aXRoU3RyaXBwZWQgPSB0cnVlO1xuLyogc3R5bGUgKi9cblxudmFyIF9fdnVlX2luamVjdF9zdHlsZXNfXyA9IHVuZGVmaW5lZDtcbi8qIHNjb3BlZCAqL1xuXG52YXIgX192dWVfc2NvcGVfaWRfXyA9IHVuZGVmaW5lZDtcbi8qIG1vZHVsZSBpZGVudGlmaWVyICovXG5cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gdW5kZWZpbmVkO1xuLyogZnVuY3Rpb25hbCB0ZW1wbGF0ZSAqL1xuXG52YXIgX192dWVfaXNfZnVuY3Rpb25hbF90ZW1wbGF0ZV9fID0gZmFsc2U7XG4vKiBzdHlsZSBpbmplY3QgKi9cblxuLyogc3R5bGUgaW5qZWN0IFNTUiAqL1xuXG4vKiBzdHlsZSBpbmplY3Qgc2hhZG93IGRvbSAqL1xuXG52YXIgX192dWVfY29tcG9uZW50X18gPSAvKiNfX1BVUkVfXyovbm9ybWFsaXplQ29tcG9uZW50KHtcbiAgcmVuZGVyOiBfX3Z1ZV9yZW5kZXJfXyxcbiAgc3RhdGljUmVuZGVyRm5zOiBfX3Z1ZV9zdGF0aWNSZW5kZXJGbnNfX1xufSwgX192dWVfaW5qZWN0X3N0eWxlc19fLCBfX3Z1ZV9zY3JpcHRfXywgX192dWVfc2NvcGVfaWRfXywgX192dWVfaXNfZnVuY3Rpb25hbF90ZW1wbGF0ZV9fLCBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fLCBmYWxzZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG5cbmZ1bmN0aW9uIHN0eWxlSW5qZWN0KGNzcywgcmVmKSB7XG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgdmFyIGluc2VydEF0ID0gcmVmLmluc2VydEF0O1xuXG4gIGlmICghY3NzIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuOyB9XG5cbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuXG4gIGlmIChpbnNlcnRBdCA9PT0gJ3RvcCcpIHtcbiAgICBpZiAoaGVhZC5maXJzdENoaWxkKSB7XG4gICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZSwgaGVhZC5maXJzdENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIGNzc18yNDh6ID0gXCIucmVzaXplLW9ic2VydmVyW2RhdGEtdi04ODU5Y2M2Y117cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3otaW5kZXg6LTE7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtib3JkZXI6bm9uZTtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O3BvaW50ZXItZXZlbnRzOm5vbmU7ZGlzcGxheTpibG9jaztvdmVyZmxvdzpoaWRkZW47b3BhY2l0eTowfS5yZXNpemUtb2JzZXJ2ZXJbZGF0YS12LTg4NTljYzZjXSBvYmplY3R7ZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJTtvdmVyZmxvdzpoaWRkZW47cG9pbnRlci1ldmVudHM6bm9uZTt6LWluZGV4Oi0xfVwiO1xuc3R5bGVJbmplY3QoY3NzXzI0OHopO1xuXG5mdW5jdGlvbiBpbnN0YWxsKFZ1ZSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIGlmIChpbnN0YWxsLmluc3RhbGxlZCkgcmV0dXJuO1xuICBpbnN0YWxsLmluc3RhbGxlZCA9IHRydWU7XG4gIHZhciBmaW5hbE9wdGlvbnMgPSB7fTtcbiAgbWVyZ2UoZmluYWxPcHRpb25zLCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gIHBsdWdpbi5vcHRpb25zID0gZmluYWxPcHRpb25zO1xuICBkaXJlY3RpdmUub3B0aW9ucyA9IGZpbmFsT3B0aW9ucztcbiAgVnVlLmRpcmVjdGl2ZSgndG9vbHRpcCcsIGRpcmVjdGl2ZSk7XG4gIFZ1ZS5kaXJlY3RpdmUoJ2Nsb3NlLXBvcG92ZXInLCB2Y2xvc2Vwb3BvdmVyKTtcbiAgVnVlLmNvbXBvbmVudCgnVlBvcG92ZXInLCBfX3Z1ZV9jb21wb25lbnRfXyk7XG59XG52YXIgVlRvb2x0aXAgPSBkaXJlY3RpdmU7XG52YXIgVkNsb3NlUG9wb3ZlciA9IHZjbG9zZXBvcG92ZXI7XG52YXIgVlBvcG92ZXIgPSBfX3Z1ZV9jb21wb25lbnRfXztcbnZhciBwbHVnaW4gPSB7XG4gIGluc3RhbGw6IGluc3RhbGwsXG5cbiAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHN0YXRlLmVuYWJsZWQ7XG4gIH0sXG5cbiAgc2V0IGVuYWJsZWQodmFsdWUpIHtcbiAgICBzdGF0ZS5lbmFibGVkID0gdmFsdWU7XG4gIH1cblxufTsgLy8gQXV0by1pbnN0YWxsXG5cbnZhciBHbG9iYWxWdWUgPSBudWxsO1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgR2xvYmFsVnVlID0gd2luZG93LlZ1ZTtcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgR2xvYmFsVnVlID0gZ2xvYmFsLlZ1ZTtcbn1cblxuaWYgKEdsb2JhbFZ1ZSkge1xuICBHbG9iYWxWdWUudXNlKHBsdWdpbik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBsdWdpbjtcbmV4cG9ydCB7IFZDbG9zZVBvcG92ZXIsIFZQb3BvdmVyLCBWVG9vbHRpcCwgY3JlYXRlVG9vbHRpcCwgZGVzdHJveVRvb2x0aXAsIGluc3RhbGwgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/v-tooltip/dist/v-tooltip.esm.js\n");

/***/ })

}]);